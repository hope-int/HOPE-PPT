<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
   
    <!-- Essential Meta Tags -->
    <title>HOPE-INT-CORE | AI-Powered Presentation, Report, Assignment & Project Generator</title>
    <meta name="description" content="Create stunning presentations, printable reports, assignments, and complete projects with AI. HOPE-INT-CORE generates custom content using Gemini AI with beautiful designs.">
    <meta name="keywords" content="presentation generator, report generator, assignment generator, project generator, AI presentations, AI reports, AI assignments, AI projects, HOPE-INT-CORE, Gemini AI">
    <meta name="author" content="Justin">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://HOPE-INT-CORE.vercel.app">
    
    <!-- Open Graph (OG) Tags -->
    <meta property="og:title" content="HOPE-INT-CORE | AI-Powered Presentation, Report, Assignment & Project Generator">
    <meta property="og:description" content="Create stunning presentations, printable reports, assignments, and complete projects with AI. HOPE-INT-CORE generates custom content using Gemini AI with beautiful designs.">
    <meta property="og:image" content="https://i.ibb.co/3yMXpZ7/Whats-App-Image-2025-09-29-at-12-03-39-AM.jpg">
    <meta property="og:url" content="https://HOPE-INT-CORE.vercel.app">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="HOPE-INT-CORE">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="HOPE-INT-CORE | AI-Powered Presentation, Report, Assignment & Project Generator">
    <meta name="twitter:description" content="Create stunning presentations, printable reports, assignments, and complete projects with AI. HOPE-INT-CORE generates custom content using Gemini AI with beautiful designs.">
    <meta name="twitter:image" content="https://HOPE-INT-CORE.vercel.app/images/twitter-preview.jpg">
    <meta name="twitter:site" content="@hopeppt">
    <meta name="twitter:creator" content="@justindev">
    
    <!-- Additional Meta Tags -->
    <meta name="theme-color" content="#3498db">
    <meta name="msapplication-TileColor" content="#3498db">
    <meta name="application-name" content="HOPE-INT-CORE">
    <meta name="apple-mobile-web-app-title" content="HOPE-INT-CORE">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <style>
        /* All existing styles remain unchanged */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #000000, #1a1a2e);
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        #three-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 80px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #3498db, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section {
            display: none;
            animation: fadeIn 0.5s ease-in-out;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }

        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 16px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(52, 152, 219, 0.3);
            transition: all 0.3s ease;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.4);
            border-color: rgba(52, 152, 219, 0.6);
        }

        input::placeholder, textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        /* Fix for select dropdown styling */
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.7rem center;
            background-size: 1.5em;
            padding-right: 2.5rem;
        }

        select option {
            background: #1a1a2e;
            color: #ffffff;
        }

        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-top: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
            background: linear-gradient(45deg, #2980b9, #3498db);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .loading-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 60vh;
        }

        .loading-text {
            font-size: 2rem;
            margin-bottom: 20px;
            animation: pulse 1.5s infinite;
            text-align: center;
            color: #3498db;
        }

        .loading-credit {
            font-size: 1.2rem;
            margin-top: 10px;
            opacity: 0;
            animation: fadeIn 1s forwards;
            animation-delay: 0.5s;
            color: rgba(255, 255, 255, 0.8);
        }

        .loading-credit:nth-child(3) {
            animation-delay: 1s;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .question-container {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(52, 152, 219, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #3498db, #2980b9);
            width: 0%;
            transition: width 0.3s ease;
        }

        .history-item {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(52, 152, 219, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .history-item button {
            padding: 8px 12px;
            font-size: 14px;
        }
        
        /* Custom color picker styles */
        .custom-colors-container {
            margin-top: 15px;
            display: none;
        }
        
        .custom-colors-container.show {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .color-picker-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .color-picker-group label {
            min-width: 120px;
            margin-right: 10px;
        }
        
        .color-picker {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .color-code {
            margin-left: 10px;
            font-family: monospace;
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
        }

        /* Language dropdown styles */
        .language-dropdown-container {
            margin-top: 15px;
            display: none;
        }
        
        .language-dropdown-container.show {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .language-search {
            margin-bottom: 10px;
        }
        
        .language-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 10px;
        }
        
        .language-option {
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .language-option:hover {
            background: rgba(52, 152, 219, 0.2);
        }
        
        .language-option.selected {
            background: rgba(52, 152, 219, 0.3);
        }

        /* Multi-select styles */
        .multi-select-container {
            margin-top: 15px;
            display: none;
        }
        
        .multi-select-container.show {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .multi-select-options {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 10px;
        }
        
        .multi-select-option {
            display: flex;
            align-items: center;
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .multi-select-option:hover {
            background: rgba(52, 152, 219, 0.2);
        }
        
        .multi-select-option input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
        }
        
        .selected-items {
            margin-top: 10px;
            padding: 8px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 8px;
            min-height: 40px;
        }
        
        .selected-item {
            display: inline-block;
            background: rgba(52, 152, 219, 0.3);
            padding: 4px 8px;
            margin: 2px;
            border-radius: 4px;
            font-size: 14px;
        }

        .preview-container {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(52, 152, 219, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transform: translateX(120%);
            transition: transform 0.3s ease;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: rgba(231, 76, 60, 0.9);
        }

        .notification.warning {
            background: rgba(241, 196, 15, 0.9);
        }

        .generating-animation {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 60vh;
        }

        .generating-text {
            font-size: 2rem;
            margin-bottom: 20px;
            text-align: center;
            color: #3498db;
        }

        .lottie-container {
            width: 200px;
            height: 200px;
            margin: 20px 0;
        }

        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(15px);
            padding: 15px;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            border-top: 1px solid rgba(52, 152, 219, 0.3);
            z-index: 100;
        }

        .option-container {
            margin-top: 15px;
        }

        .option {
            display: block;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option:hover {
            background: rgba(52, 152, 219, 0.2);
            border-color: rgba(52, 152, 219, 0.6);
        }

        .option.selected {
            background: rgba(52, 152, 219, 0.3);
            border-color: #3498db;
        }

        .option input[type="radio"] {
            display: none;
        }

        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000000, #1a1a2e);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 1s ease;
        }

        .splash-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .splash-title {
            font-size: 3rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #3498db, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .splash-subtitle {
            font-size: 1.5rem;
            margin-bottom: 30px;
            color: rgba(255, 255, 255, 0.8);
        }

        .splash-animation {
            width: 300px;
            height: 300px;
            margin: 20px auto;
        }

        .splash-footer {
            margin-top: 40px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .splash-continue {
            margin-top: 30px;
            padding: 12px 30px;
            font-size: 1.1rem;
            background: linear-gradient(45deg, #3498db, #2980b9);
            border: none;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .splash-continue:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(52, 152, 219, 0.4);
        }

        .history-btn {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
            z-index: 99;
            transition: all 0.3s ease;
        }

        .history-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.6);
        }

        /* Main Options Styles */
        .main-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 30px;
        }
        
        .option-card {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(52, 152, 219, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .option-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(52, 152, 219, 0.4);
            border-color: rgba(52, 152, 219, 0.6);
        }
        
        .option-card h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #3498db;
        }
        
        .option-card p {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .font-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            display: none;
        }
        
        .font-list.show {
            display: block;
        }
        
        .font-option {
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .font-option:hover {
            background: rgba(52, 152, 219, 0.2);
        }
        
        .font-option.selected {
            background: rgba(52, 152, 219, 0.3);
        }

        /* Tutorial Section Styles */
        .tutorial-section {
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
        }

        .tutorial-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .tutorial-header h2 {
            font-size: 2.5rem;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #3498db, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tutorial-header p {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .tutorial-steps {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .tutorial-step {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(52, 152, 219, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .step-number {
            display: inline-block;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            border-radius: 50%;
            text-align: center;
            line-height: 40px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .step-content h3 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #3498db;
        }

        .step-content p {
            margin-bottom: 15px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.9);
        }

        .step-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .step-content li {
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.9);
        }

        .step-image {
            width: 100%;
            max-width: 600px;
            height: auto;
            border-radius: 10px;
            margin: 15px auto;
            display: block;
            border: 2px solid rgba(52, 152, 219, 0.3);
        }

        .tutorial-actions {
            text-align: center;
            margin-top: 40px;
        }

        .tutorial-note {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid #3498db;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .tutorial-note p {
            margin: 0;
            color: rgba(255, 255, 255, 0.9);
        }

        /* Assignment Section Styles */
        .assignment-section {
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
        }

        .assignment-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .assignment-header h2 {
            font-size: 2.5rem;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #3498db, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .assignment-header p {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .assignment-steps {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .assignment-step {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(52, 152, 219, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .step-number {
            display: inline-block;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            border-radius: 50%;
            text-align: center;
            line-height: 40px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .step-content h3 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #3498db;
        }

        .step-content p {
            margin-bottom: 15px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.9);
        }

        .step-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .step-content li {
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.9);
        }

        .step-image {
            width: 100%;
            max-width: 600px;
            height: auto;
            border-radius: 10px;
            margin: 15px auto;
            display: block;
            border: 2px solid rgba(52, 152, 219, 0.3);
        }

        .assignment-actions {
            text-align: center;
            margin-top: 40px;
        }

        .assignment-note {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid #3498db;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .assignment-note p {
            margin: 0;
            color: rgba(255, 255, 255, 0.9);
        }

        /* Project Section Styles */
        .project-section {
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
        }

        .project-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .project-header h2 {
            font-size: 2.5rem;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #3498db, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .project-header p {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .project-steps {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .project-step {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(52, 152, 219, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .project-actions {
            text-align: center;
            margin-top: 40px;
        }

        .project-note {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid #3498db;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .project-note p {
            margin: 0;
            color: rgba(255, 255, 255, 0.9);
        }

        .file-list {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .file-name {
            font-weight: 500;
        }

        .file-size {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }

        /* Network Status Indicator */
        .network-status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .network-status.online {
            background: rgba(46, 204, 113, 0.7);
        }

        .network-status.offline {
            background: rgba(231, 76, 60, 0.7);
        }

        .network-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: white;
        }

        .network-status.online .network-status-dot {
            background-color: #2ecc71;
        }

        .network-status.offline .network-status-dot {
            background-color: #e74c3c;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            button {
                width: 100%;
                margin-right: 0;
            }
            
            .splash-title {
                font-size: 2.5rem;
            }
            
            .splash-subtitle {
                font-size: 1.2rem;
            }

            .tutorial-header h2 {
                font-size: 2rem;
            }

            .step-content h3 {
                font-size: 1.3rem;
            }

            .assignment-header h2 {
                font-size: 2rem;
            }

            .step-content h3 {
                font-size: 1.3rem;
            }

            .project-header h2 {
                font-size: 2rem;
            }

            .step-content h3 {
                font-size: 1.3rem;
            }
        }
    </style>
</head>
<body>
    <!-- Network Status Indicator -->
    <div id="network-status" class="network-status">
        <div class="network-status-dot"></div>
        <span id="network-status-text">Checking...</span>
    </div>

    <!-- Splash Screen -->
    <div id="splash-screen" class="splash-screen">
        <div class="splash-content">
            <h1 class="splash-title">HOPE-INT-CORE</h1>
            <p class="splash-subtitle">Create stunning presentations, printable reports, assignments, and complete projects with AI</p>
            <div class="splash-animation">
                <lottie-player src="https://assets4.lottiefiles.com/packages/lf20_DMgKk1.json" background="transparent" speed="1" loop autoplay></lottie-player>
            </div>
            <div class="splash-footer">
                <p>Developed by Justin</p>
                <p>Under HOPE Research & development Team</p>
            </div>
            <button class="splash-continue" id="continue-to-app">Continue to App</button>
        </div>
    </div>

    <div id="three-background"></div>
    
    <div class="container">
        <h1>HOPE-INT-CORE</h1>
        
        <!-- Tutorial Section -->
        <div id="tutorial-section" class="section">
            <div class="tutorial-section">
                <div class="tutorial-header">
                    <h2>Welcome to HOPE-INT-CORE!</h2>
                    <p>Let's get you set up with your Gemini API key to start creating amazing presentations, reports, assignments, and projects</p>
                </div>
                
                <div class="tutorial-steps">
                    <div class="tutorial-step">
                        <div class="step-number">1</div>
                        <div class="step-content">
                            <h3>What is a Gemini API Key?</h3>
                            <p>The Gemini API key is a unique identifier that allows HOPE-INT-CORE to access Google's powerful Gemini AI model to generate your presentations, reports, assignments, and projects. It's like a password that gives our app permission to use Google's AI services.</p>
                            <div class="tutorial-note">
                                <p><strong>Note:</strong> Your API key is private and should never be shared with others. We store it securely in your browser only.</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="tutorial-step">
                        <div class="step-number">2</div>
                        <div class="step-content">
                            <h3>Getting Your Gemini API Key</h3>
                            <p>Follow these steps to get your free API key from Google:</p>
                            <ul>
                                <li>Go to <a href="https://makersuite.google.com/app/apikey" target="_blank" style="color: #3498db;">Google AI Studio</a></li>
                                <li>Sign in with your Google account</li>
                                <li>Click on "Get API Key" button</li>
                                <li>Choose "Create API key in new project"</li>
                                <li>Create a new project and select it</li>
                                <li>Copy the generated API key</li>
                            </ul>
                            <img src="https://i.ibb.co/fY5w6PhH/Whats-App-Image-2025-09-28-at-11-58-35-PM.jpg" alt="Google AI Studio interface" class="step-image">
                        </div>
                    </div>
                    
                    <div class="tutorial-step">
                        <div class="step-number">3</div>
                        <div class="step-content">
                            <h3>API Key Benefits</h3>
                            <p>With your Gemini API key, you can:</p>
                            <ul>
                                <li>Generate unlimited presentations, reports, assignments, and projects</li>
                                <li>Access the latest AI models</li>
                                <li>Create content in multiple languages</li>
                                <li>Use advanced design features</li>
                                <li>Save and manage your history</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="tutorial-step">
                        <div class="step-number">4</div>
                        <div class="step-content">
                            <h3>Security & Privacy</h3>
                            <p>Your API key is stored locally in your browser and is never sent to our servers. Google's AI processes your topics, but we don't store any of your content or personal information.</p>
                            <div class="tutorial-note">
                                <p><strong>Important:</strong> Never share your API key publicly or commit it to code repositories.</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="tutorial-actions">
                    <button id="got-it-btn" class="splash-continue">I Understand, Take Me to API Key Setup</button>
                </div>
            </div>
        </div>
        
        <!-- API Key Section -->
        <div id="api-key-section" class="section">
            <div class="form-group">
                <label for="api-key">Enter your Gemini API Key:</label>
                <input type="password" id="api-key" placeholder="Your Gemini API Key">
            </div>
            <button id="save-api-key">Save API Key</button>
            <div id="api-status"></div>
            <div style="margin-top: 20px;">
                <button id="show-tutorial-btn" style="background: rgba(52, 152, 219, 0.3);">Need Help? Show Tutorial</button>
            </div>
        </div>
        
        <!-- Loading Screen -->
        <div id="loading-section" class="section">
            <div class="loading-screen">
                <div class="loading-text">AI now Getting ready</div>
                <div class="loading-credit">Developed by Justin</div>
                <div class="loading-credit">Developed under HOPE Research & development Team</div>
                <div class="lottie-container">
                    <lottie-player src="https://assets9.lottiefiles.com/packages/lf20_DMgKk1.json" background="transparent" speed="1" loop autoplay></lottie-player>
                </div>
            </div>
        </div>
        
        <!-- Main Options Section -->
        <div id="main-options-section" class="section">
            <h2>What would you like to create?</h2>
            <div class="main-options">
                <div class="option-card" id="create-ppt-card">
                    <h3>Create Presentation</h3>
                    <p>Generate an interactive 3D presentation with animations and multimedia elements</p>
                </div>
                <div class="option-card" id="create-report-card">
                    <h3>Create Printable Report</h3>
                    <p>Generate a professional report that can be downloaded as PDF</p>
                </div>
                <div class="option-card" id="create-assignment-card">
                    <h3>Create Assignment</h3>
                    <p>Generate a detailed assignment with questions, instructions, and grading criteria</p>
                </div>
                <div class="option-card" id="create-project-card">
                    <h3>Create Complete Project</h3>
                    <p>Generate a complete mini/final year project with source code, documentation, and workflow diagrams</p>
                </div>
            </div>
        </div>
        
        <!-- Topic Input Section -->
        <div id="topic-section" class="section">
            <div class="form-group">
                <label for="presentation-topic">Enter your presentation topic:</label>
                <input type="text" id="presentation-topic" placeholder="e.g., Climate Change, Artificial Intelligence, etc.">
            </div>
            <button id="generate-questions">Generate Questions</button>
        </div>
        
        <!-- Report Topic Section -->
        <div id="report-topic-section" class="section">
            <div class="form-group">
                <label for="report-topic">Enter your report topic:</label>
                <input type="text" id="report-topic" placeholder="e.g., Climate Change, Artificial Intelligence, etc.">
            </div>
            <button id="generate-classification-questions">Next</button>
        </div>
        
        <!-- Assignment Topic Section -->
        <div id="assignment-topic-section" class="section">
            <div class="form-group">
                <label for="assignment-topic">Enter your assignment topic:</label>
                <input type="text" id="assignment-topic" placeholder="e.g., Climate Change, Artificial Intelligence, etc.">
            </div>
            <button id="generate-assignment-classification-questions">Next</button>
        </div>
        
        <!-- Project Topic Section -->
        <div id="project-topic-section" class="section">
            <div class="form-group">
                <label for="project-topic">Enter your project topic:</label>
                <input type="text" id="project-topic" placeholder="e.g., E-commerce Website, Mobile App, Data Analysis System, etc.">
            </div>
            <div class="form-group">
                <label for="project-level">Select project level:</label>
                <select id="project-level">
                    <option value="">Select project level</option>
                    <option value="mini">Mini Project</option>
                    <option value="final">Final Year Project</option>
                </select>
            </div>
            <button id="generate-project-classification-questions">Next</button>
        </div>
        
        <!-- Generating Classification Questions Section -->
        <div id="generating-classification-section" class="section">
            <div class="generating-animation">
                <div class="generating-text">Generating classification questions...</div>
                <div class="lottie-container">
                    <lottie-player src="https://assets4.lottiefiles.com/packages/lf20_fcfjwiyb.json" background="transparent" speed="1" loop autoplay></lottie-player>
                </div>
                <p>AI is analyzing your topic to create personalized questions</p>
            </div>
        </div>
        
        <!-- Generating Assignment Classification Questions Section -->
        <div id="generating-assignment-classification-section" class="section">
            <div class="generating-animation">
                <div class="generating-text">Generating assignment classification questions...</div>
                <div class="lottie-container">
                    <lottie-player src="https://assets4.lottiefiles.com/packages/lf20_fcfjwiyb.json" background="transparent" speed="1" loop autoplay></lottie-player>
                </div>
                <p>AI is analyzing your topic to create personalized questions</p>
            </div>
        </div>
        
        <!-- Generating Project Classification Questions Section -->
        <div id="generating-project-classification-section" class="section">
            <div class="generating-animation">
                <div class="generating-text">Generating project classification questions...</div>
                <div class="lottie-container">
                    <lottie-player src="https://assets4.lottiefiles.com/packages/lf20_fcfjwiyb.json" background="transparent" speed="1" loop autoplay></lottie-player>
                </div>
                <p>AI is analyzing your topic to create personalized questions</p>
            </div>
        </div>
        
        <!-- Generating PPT Classification Questions Section -->
        <div id="generating-ppt-classification-section" class="section">
            <div class="generating-animation">
                <div class="generating-text">Generating presentation classification questions...</div>
                <div class="lottie-container">
                    <lottie-player src="https://assets4.lottiefiles.com/packages/lf20_fcfjwiyb.json" background="transparent" speed="1" loop autoplay></lottie-player>
                </div>
                <p>AI is analyzing your topic to create personalized questions</p>
            </div>
        </div>
        
        <!-- Classification Questions Section -->
        <div id="classification-questions-section" class="section">
            <div class="progress-bar">
                <div class="progress-fill" id="classification-progress-fill"></div>
            </div>
            <div id="classification-questions-container"></div>
            <button id="finish-classification-btn" disabled>Continue to Report Options</button>
        </div>
        
        <!-- Assignment Classification Questions Section -->
        <div id="assignment-classification-questions-section" class="section">
            <div class="progress-bar">
                <div class="progress-fill" id="assignment-classification-progress-fill"></div>
            </div>
            <div id="assignment-classification-questions-container"></div>
            <button id="finish-assignment-classification-btn" disabled>Continue to Assignment Options</button>
        </div>
        
        <!-- Project Classification Questions Section -->
        <div id="project-classification-questions-section" class="section">
            <div class="progress-bar">
                <div class="progress-fill" id="project-classification-progress-fill"></div>
            </div>
            <div id="project-classification-questions-container"></div>
            <button id="finish-project-classification-btn" disabled>Continue to Project Options</button>
        </div>
        
        <!-- PPT Classification Questions Section -->
        <div id="ppt-classification-questions-section" class="section">
            <div class="progress-bar">
                <div class="progress-fill" id="ppt-classification-progress-fill"></div>
            </div>
            <div id="ppt-classification-questions-container"></div>
            <button id="finish-ppt-classification-btn" disabled>Continue to Presentation Options</button>
        </div>
        
        <!-- Questions Section -->
        <div id="questions-section" class="section">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div id="questions-container"></div>
            <div id="custom-colors-container" class="custom-colors-container">
                <div class="color-picker-group">
                    <label for="custom-color-1">First Color:</label>
                    <input type="color" id="custom-color-1" class="color-picker" value="#3498db">
                    <span id="color-code-1" class="color-code">#3498db</span>
                </div>
                <div class="color-picker-group">
                    <label for="custom-color-2">Second Color:</label>
                    <input type="color" id="custom-color-2" class="color-picker" value="#e74c3c">
                    <span id="color-code-2" class="color-code">#e74c3c</span>
                </div>
            </div>
            <div id="language-dropdown-container" class="language-dropdown-container">
                <div class="language-search">
                    <input type="text" id="language-search" placeholder="Search languages...">
                </div>
                <div id="language-list" class="language-list"></div>
            </div>
            <button id="generate-presentation" disabled>Generate Presentation</button>
        </div>
        
        <!-- Report Questions Section -->
        <div id="report-questions-section" class="section">
            <div class="progress-bar">
                <div class="progress-fill" id="report-progress-fill"></div>
            </div>
            <div id="report-questions-container"></div>
            <div id="font-list-container" class="font-list">
                <!-- Font options will be populated here -->
            </div>
            <button id="generate-report" disabled>Generate Report</button>
        </div>
        
        <!-- Assignment Questions Section -->
        <div id="assignment-questions-section" class="section">
            <div class="progress-bar">
                <div class="progress-fill" id="assignment-progress-fill"></div>
            </div>
            <div id="assignment-questions-container"></div>
            <div id="assignment-font-list-container" class="font-list">
                <!-- Font options will be populated here -->
            </div>
            <button id="generate-assignment" disabled>Generate Assignment</button>
        </div>
        
        <!-- Project Questions Section -->
        <div id="project-questions-section" class="section">
            <div class="progress-bar">
                <div class="progress-fill" id="project-progress-fill"></div>
            </div>
            <div id="project-questions-container"></div>
            <div id="project-font-list-container" class="font-list">
                <!-- Font options will be populated here -->
            </div>
            <button id="generate-project" disabled>Generate Project</button>
        </div>
        
        <!-- Generating Section -->
        <div id="generating-section" class="section">
            <div class="generating-animation">
                <div class="generating-text">Creating your presentation...</div>
                <div class="lottie-container">
                    <lottie-player src="https://assets4.lottiefiles.com/packages/lf20_fcfjwiyb.json" background="transparent" speed="1" loop autoplay></lottie-player>
                </div>
                <p>This may take a moment as we generate your custom 3D presentation</p>
            </div>
        </div>
        
        <!-- Generating Report Section -->
        <div id="generating-report-section" class="section">
            <div class="generating-animation">
                <div class="generating-text">Creating your report...</div>
                <div class="lottie-container">
                    <lottie-player src="https://assets4.lottiefiles.com/packages/lf20_fcfjwiyb.json" background="transparent" speed="1" loop autoplay></lottie-player>
                </div>
                <p>This may take a moment as we generate your custom report</p>
            </div>
        </div>
        
        <!-- Generating Assignment Section -->
        <div id="generating-assignment-section" class="section">
            <div class="generating-animation">
                <div class="generating-text">Creating your assignment...</div>
                <div class="lottie-container">
                    <lottie-player src="https://assets4.lottiefiles.com/packages/lf20_fcfjwiyb.json" background="transparent" speed="1" loop autoplay></lottie-player>
                </div>
                <p>This may take a moment as we generate your custom assignment</p>
            </div>
        </div>
        
        <!-- Generating Project Section -->
        <div id="generating-project-section" class="section">
            <div class="generating-animation">
                <div class="generating-text">Creating your complete project...</div>
                <div class="lottie-container">
                    <lottie-player src="https://assets4.lottiefiles.com/packages/lf20_fcfjwiyb.json" background="transparent" speed="1" loop autoplay></lottie-player>
                </div>
                <p>This may take a moment as we generate your complete project with source code, documentation, and workflow diagrams</p>
            </div>
        </div>
        
        <!-- Preview Section -->
        <div id="preview-section" class="section">
            <h2>Your presentation is ready!</h2>
            <div class="preview-container">
                <button id="preview-btn">Preview in New Tab</button>
                <button id="download-ppt-btn">Download HTML</button>
                <button id="new-presentation-btn">Create New Presentation</button>
            </div>
        </div>
        
        <!-- Report Preview Section -->
        <div id="report-preview-section" class="section">
            <h2>Your report is ready!</h2>
            <div class="preview-container">
                <button id="preview-report-btn">Preview in New Tab</button>
                <button id="download-report-btn">Download as PDF</button>
                <button id="new-report-btn">Create New Report</button>
            </div>
        </div>
        
        <!-- Assignment Preview Section -->
        <div id="assignment-preview-section" class="section">
            <h2>Your assignment is ready!</h2>
            <div class="preview-container">
                <button id="preview-assignment-btn">Preview in New Tab</button>
                <button id="download-assignment-btn">Download as PDF</button>
                <button id="new-assignment-btn">Create New Assignment</button>
            </div>
        </div>
        
        <!-- Project Preview Section -->
        <div id="project-preview-section" class="section">
            <h2>Your complete project is ready!</h2>
            <div class="file-list" id="project-file-list">
                <!-- Project files will be listed here -->
            </div>
            <div class="preview-container">
                <button id="download-project-btn">Download Complete Project</button>
                <button id="preview-documentation-btn">Preview Documentation</button>
                <button id="new-project-btn">Create New Project</button>
            </div>
        </div>
        
        <!-- History Section -->
        <div id="history-section" class="section">
            <h2>Recent Creations</h2>
            <div id="history-container"></div>
            <button id="clear-history-btn">Clear History</button>
            <button id="new-creation-from-history-btn">Create New</button>
        </div>
    </div>
    
    <footer>
        Developed under HOPE Research Team | Developed by Justin
    </footer>
    
    <button class="history-btn" id="history-toggle" title="View History"></button>
    
    <div id="notification" class="notification"></div>

    <script>
        // Application State
        const appState = {
            apiKey: '',
            topic: '',
            theme: '',
            slideCount: '',
            structure: '',
            animationStyle: '',
            colorTheme: '',
            customColor1: '#3498db',
            customColor2: '#e74c3c',
            descriptionLength: '',
            bulletPointsCount: '',
            fontSize: '',
            includeImages: '',
            termsdepth: '',
            bgitem: '',
            language: 'English',
            presentationStyle: '',
            advancedAnimations: '',
            interactiveElements: '',
            dataVisualization: '',
            multimediaElements: '',
            imageFallback: '',
            generatedPresentation: '',
            currentQuestionIndex: 0,
            presentationHistory: [],
            reportHistory: [],
            assignmentHistory: [],
            projectHistory: [],
            hasSeenTutorial: false,
            isOnline: navigator.onLine,
            
            // Report-specific state
            reportTopic: '',
            reportFontSize: '',
            reportFont: '',
            reportStyle: '',
            reportElements: '',
            selectedFont: '',
            generatedReport: '',
            currentReportQuestionIndex: 0,
            reportQuestions: [],
            reportAnswers: [],
            
            // Assignment-specific state
            assignmentTopic: '',
            assignmentGradeLevel: '',
            assignmentSubject: '',
            assignmentType: '',
            assignmentLength: '',
            assignmentDifficulty: '',
            assignmentResources: '',
            assignmentSubmission: '',
            selectedAssignmentFont: '',
            generatedAssignment: '',
            currentAssignmentQuestionIndex: 0,
            assignmentQuestions: [],
            assignmentAnswers: [],
            
            // Project-specific state
            projectTopic: '',
            projectLevel: '',
            projectType: '',
            projectComplexity: '',
            projectLanguages: [],
            projectFramework: '',
            projectDatabase: '',
            projectUI: '',
            projectDocumentation: '',
            projectDeployment: '',
            selectedProjectFont: '',
            generatedProject: {},
            currentProjectQuestionIndex: 0,
            projectQuestions: [],
            projectAnswers: [],
            projectFiles: [],
            includeCurrentDate: false,
            currentDateTime: '',
            
            // Classification questions state
            classificationQuestions: [],
            classificationAnswers: [],
            currentClassificationQuestionIndex: 0,
            
            // Assignment classification questions state
            assignmentClassificationQuestions: [],
            assignmentClassificationAnswers: [],
            currentAssignmentClassificationQuestionIndex: 0,
            
            // Project classification questions state
            projectClassificationQuestions: [],
            projectClassificationAnswers: [],
            currentProjectClassificationQuestionIndex: 0,
            
            // PPT classification questions state
            pptClassificationQuestions: [],
            pptClassificationAnswers: [],
            currentPptClassificationQuestionIndex: 0
        };

        // List of languages that LLMs are typically trained on
        const languages = [
            "English", "Spanish", "French", "German", "Italian", "Portuguese", "Dutch", "Russian", 
            "Japanese", "Korean", "Chinese (Simplified)", "Chinese (Traditional)", "Arabic", 
            "Hindi", "Bengali", "Punjabi", "Marathi", "Tamil", "Telugu", "Gujarati", "Kannada", 
            "Malayalam", "Odia", "Assamese", "Urdu", "Persian", "Turkish", "Polish", "Ukrainian", 
            "Romanian", "Czech", "Hungarian", "Swedish", "Danish", "Norwegian", "Finnish", 
            "Greek", "Hebrew", "Thai", "Vietnamese", "Indonesian", "Malay", "Tagalog", 
            "Swahili", "Zulu", "Afrikaans", "Amharic", "Yoruba", "Igbo", "Somali", 
            "Nepali", "Sinhala", "Burmese", "Khmer", "Lao", "Mongolian", "Kazakh", 
            "Uzbek", "Azerbaijani", "Georgian", "Armenian", "Lithuanian", "Latvian", 
            "Estonian", "Slovak", "Slovenian", "Croatian", "Serbian", "Bosnian", 
            "Montenegrin", "Macedonian", "Bulgarian", "Albanian", "Belarusian", 
            "Moldovan", "Icelandic", "Faroese", "Basque", "Catalan", "Galician", 
            "Welsh", "Irish", "Scottish Gaelic", "Breton", "Cornish", "Manx", 
            "Esperanto", "Latin", "Ancient Greek", "Sanskrit", "Pali", "Tibetan", 
            "Mongolian (Traditional)", "Javanese", "Sundanese", "Madurese", "Balinese", 
            "Minangkabau", "Buginese", "Makassarese", "Acehnese", "Banjarese", 
            "Tausug", "Maguindanao", "Maranao", "Ilocano", "Hiligaynon", "Waray-Waray", 
            "Bicolano", "Pangasinan", "Kapampangan", "Ibanag", "Gaddang", "Ifugao", 
            "Kalinga", "Bontoc", "Tboli", "T'boli", "Manobo", "Bagobo", "Mandaya", 
            "Mansaka", "Dibabawon", "Manguangan", "Kalagan", "Tagakaulo", "Blan", 
            "Talaandig", "Higaonon", "Bukidnon", "Tigwahanon", "Matigsalug", "Obo", 
            "Tinananon", "Tigwa", "Umayamnon", "Western Bukidnon Manobo", "Eastern Bukidnon Manobo", 
            "Kinamiging", "Cotabato Manobo", "Dibabawon Manobo", "Agusan Manobo", 
            "Surigao Manobo", "Western Visayan", "Central Visayan", "Southern Visayan", 
            "Northern Visayan", "Ati", "Sulod", "Magahat", "Negros Occidental Hiligaynon", 
            "Capiznon", "Aklanon", "Kinaray-a", "Cuyonon", "Ratagnon", "Batak", 
            "Palawano", "Tagbanwa", "Cuyonon", "Agutaynen", "Tausug", "Sama", 
            "Yakan", "Jama Mapun", "Sama-Bajau", "Badjao", "Molbog", "Palawano", "Tagbanwa", 
            "Cuyonon", "Agutaynen", "Tausug", "Sama", "Yakan", "Jama Mapun", "Sama-Bajau", 
            "Badjao", "Molbog", "Palawano", "Tagbanwa", "Cuyonon", "Agutaynen"
        ];
        
        // List of programming languages for projects
        const programmingLanguages = [
            "JavaScript/TypeScript", "Python", "Java", "C#", "PHP", "Ruby", "Go", "Swift", 
            "Kotlin", "C++", "C", "Rust", "Scala", "Perl", "MATLAB", "R", "SQL", "HTML/CSS",
            "Dart", "Lua", "Assembly", "VB.NET", "Objective-C", "F#", "Haskell", "Elixir",
            "Erlang", "Clojure", "Groovy", "Julia", "TypeScript", "Bash", "PowerShell"
        ];
        
        // List of fonts for report, assignment, and project
        const fonts = [
            "Arial", "Verdana", "Helvetica", "Times New Roman", "Georgia", 
            "Courier New", "Brush Script MT", "Lucida Handwriting", "Comic Sans MS",
            "Impact", "Lucida Console", "Tahoma", "Trebuchet MS", "Palatino",
            "Garamond", "Bookman", "Century Gothic", "Franklin Gothic Medium"
        ];

        // Fallback classification questions for when AI response is invalid
        const fallbackClassificationQuestions = [
            {
                question: "What is the primary purpose of this report?",
                options: ["Informative", "Analytical", "Persuasive", "Instructional"]
            },
            {
                question: "Who is the target audience for this report?",
                options: ["General public", "Professionals", "Academics", "Executives"]
            },
            {
                question: "What is the expected length of the report?",
                options: ["Short (1-3 pages)", "Medium (4-10 pages)", "Long (11+ pages)"]
            },
            {
                question: "What level of detail is required?",
                options: ["Overview", "In-depth", "Comprehensive"]
            },
            {
                question: "Should the report include data and statistics?",
                options: ["Yes, extensively", "Yes, moderately", "No"]
            },
            {
                question: "What type of visuals should be included?",
                options: ["Charts and graphs", "Images and diagrams", "Tables", "No visuals"]
            },
            {
                question: "Should the report include references or citations?",
                options: ["Yes, formal", "Yes, informal", "No"]
            },
            {
                question: "What is the desired tone of the report?",
                options: ["Formal", "Neutral", "Conversational", "Technical"]
            },
            {
                question: "Should the report include recommendations?",
                options: ["Yes, detailed", "Yes, brief", "No"]
            },
            {
                question: "What is the time frame covered by the report?",
                options: ["Current status", "Historical", "Future projection", "Combination"]
            }
        ];

        // Fallback assignment classification questions
        const fallbackAssignmentClassificationQuestions = [
            {
                question: "What is the grade level for this assignment?",
                options: ["Elementary (K-5)", "Middle School (6-8)", "High School (9-12)", "College/University"]
            },
            {
                question: "What subject area does this assignment belong to?",
                options: ["Science", "Mathematics", "Language Arts", "Social Studies", "Arts", "Technology", "Physical Education"]
            },
            {
                question: "What type of assignment do you want to create?",
                options: ["Essay/Research Paper", "Problem Set", "Project-based", "Quiz/Test", "Presentation", "Lab Report"]
            },
            {
                question: "How long should the assignment be?",
                options: ["Short (1-2 pages)", "Medium (3-5 pages)", "Long (6+ pages)"]
            },
            {
                question: "What difficulty level is appropriate?",
                options: ["Beginner", "Intermediate", "Advanced", "Mixed Levels"]
            }
        ];

        // Fallback project classification questions
        const fallbackProjectClassificationQuestions = [
            {
                question: "What type of project do you want to create?",
                options: ["Web Application", "Mobile App", "Desktop Software", "Data Analysis System", "Machine Learning Model", "IoT Solution"]
            },
            {
                question: "What is the primary purpose of this project?",
                options: ["Educational", "Business", "Personal", "Research", "Entertainment"]
            },
            {
                question: "Who is the target audience for this project?",
                options: ["Students", "Professionals", "General public", "Specific industry", "Researchers"]
            },
            {
                question: "What is the expected complexity level?",
                options: ["Beginner", "Intermediate", "Advanced", "Expert"]
            },
            {
                question: "What is the preferred development timeline?",
                options: ["1-2 weeks", "3-4 weeks", "1-2 months", "3+ months"]
            }
        ];

        // Fallback PPT classification questions
        const fallbackPptClassificationQuestions = [
            {
                question: "What is the primary purpose of this presentation?",
                options: ["Educational", "Business", "Informative", "Entertainment"]
            },
            {
                question: "Who is the target audience?",
                options: ["Students", "Professionals", "General public", "Executives"]
            },
            {
                question: "What presentation style do you prefer?",
                options: ["Formal", "Casual", "Creative", "Technical"]
            },
            {
                question: "How detailed should the content be?",
                options: ["Overview", "Moderate detail", "In-depth", "Comprehensive"]
            },
            {
                question: "What type of visuals do you want?",
                options: ["Minimal", "Moderate", "Extensive", "Interactive"]
            }
        ];

        // DOM Elements
        const sections = {
            tutorial: document.getElementById('tutorial-section'),
            apiKey: document.getElementById('api-key-section'),
            loading: document.getElementById('loading-section'),
            mainOptions: document.getElementById('main-options-section'),
            topic: document.getElementById('topic-section'),
            reportTopic: document.getElementById('report-topic-section'),
            assignmentTopic: document.getElementById('assignment-topic-section'),
            projectTopic: document.getElementById('project-topic-section'),
            generatingClassification: document.getElementById('generating-classification-section'),
            generatingAssignmentClassification: document.getElementById('generating-assignment-classification-section'),
            generatingProjectClassification: document.getElementById('generating-project-classification-section'),
            generatingPptClassification: document.getElementById('generating-ppt-classification-section'),
            classificationQuestions: document.getElementById('classification-questions-section'),
            assignmentClassificationQuestions: document.getElementById('assignment-classification-questions-section'),
            projectClassificationQuestions: document.getElementById('project-classification-questions-section'),
            pptClassificationQuestions: document.getElementById('ppt-classification-questions-section'),
            questions: document.getElementById('questions-section'),
            reportQuestions: document.getElementById('report-questions-section'),
            assignmentQuestions: document.getElementById('assignment-questions-section'),
            projectQuestions: document.getElementById('project-questions-section'),
            generating: document.getElementById('generating-section'),
            generatingReport: document.getElementById('generating-report-section'),
            generatingAssignment: document.getElementById('generating-assignment-section'),
            generatingProject: document.getElementById('generating-project-section'),
            preview: document.getElementById('preview-section'),
            reportPreview: document.getElementById('report-preview-section'),
            assignmentPreview: document.getElementById('assignment-preview-section'),
            projectPreview: document.getElementById('project-preview-section'),
            history: document.getElementById('history-section')
        };

        const elements = {
            apiKeyInput: document.getElementById('api-key'),
            saveApiKeyBtn: document.getElementById('save-api-key'),
            apiStatus: document.getElementById('api-status'),
            presentationTopic: document.getElementById('presentation-topic'),
            generateQuestionsBtn: document.getElementById('generate-questions'),
            questionsContainer: document.getElementById('questions-container'),
            progressFill: document.getElementById('progress-fill'),
            generatePresentationBtn: document.getElementById('generate-presentation'),
            previewBtn: document.getElementById('preview-btn'),
            downloadPptBtn: document.getElementById('download-ppt-btn'),
            newPresentationBtn: document.getElementById('new-presentation-btn'),
            historyContainer: document.getElementById('history-container'),
            clearHistoryBtn: document.getElementById('clear-history-btn'),
            newCreationFromHistoryBtn: document.getElementById('new-creation-from-history-btn'),
            notification: document.getElementById('notification'),
            historyToggle: document.getElementById('history-toggle'),
            splashScreen: document.getElementById('splash-screen'),
            continueToApp: document.getElementById('continue-to-app'),
            customColorsContainer: document.getElementById('custom-colors-container'),
            languageDropdownContainer: document.getElementById('language-dropdown-container'),
            languageSearch: document.getElementById('language-search'),
            languageList: document.getElementById('language-list'),
            gotItBtn: document.getElementById('got-it-btn'),
            showTutorialBtn: document.getElementById('show-tutorial-btn'),
            networkStatus: document.getElementById('network-status'),
            networkStatusText: document.getElementById('network-status-text'),
            
            // Report elements
            createPptCard: document.getElementById('create-ppt-card'),
            createReportCard: document.getElementById('create-report-card'),
            reportTopicInput: document.getElementById('report-topic'),
            generateClassificationQuestionsBtn: document.getElementById('generate-classification-questions'),
            classificationQuestionsContainer: document.getElementById('classification-questions-container'),
            classificationProgressFill: document.getElementById('classification-progress-fill'),
            finishClassificationBtn: document.getElementById('finish-classification-btn'),
            reportQuestionsContainer: document.getElementById('report-questions-container'),
            reportProgressFill: document.getElementById('report-progress-fill'),
            generateReportBtn: document.getElementById('generate-report'),
            fontListContainer: document.getElementById('font-list-container'),
            previewReportBtn: document.getElementById('preview-report-btn'),
            downloadReportBtn: document.getElementById('download-report-btn'),
            newReportBtn: document.getElementById('new-report-btn'),
            
            // Assignment elements
            createAssignmentCard: document.getElementById('create-assignment-card'),
            assignmentTopicInput: document.getElementById('assignment-topic'),
            generateAssignmentClassificationQuestionsBtn: document.getElementById('generate-assignment-classification-questions'),
            assignmentClassificationQuestionsContainer: document.getElementById('assignment-classification-questions-container'),
            assignmentClassificationProgressFill: document.getElementById('assignment-classification-progress-fill'),
            finishAssignmentClassificationBtn: document.getElementById('finish-assignment-classification-btn'),
            assignmentQuestionsContainer: document.getElementById('assignment-questions-container'),
            assignmentProgressFill: document.getElementById('assignment-progress-fill'),
            generateAssignmentBtn: document.getElementById('generate-assignment'),
            assignmentFontListContainer: document.getElementById('assignment-font-list-container'),
            previewAssignmentBtn: document.getElementById('preview-assignment-btn'),
            downloadAssignmentBtn: document.getElementById('download-assignment-btn'),
            newAssignmentBtn: document.getElementById('new-assignment-btn'),
            
            // Project elements
            createProjectCard: document.getElementById('create-project-card'),
            projectTopicInput: document.getElementById('project-topic'),
            projectLevelSelect: document.getElementById('project-level'),
            generateProjectClassificationQuestionsBtn: document.getElementById('generate-project-classification-questions'),
            projectClassificationQuestionsContainer: document.getElementById('project-classification-questions-container'),
            projectClassificationProgressFill: document.getElementById('project-classification-progress-fill'),
            finishProjectClassificationBtn: document.getElementById('finish-project-classification-btn'),
            projectQuestionsContainer: document.getElementById('project-questions-container'),
            projectProgressFill: document.getElementById('project-progress-fill'),
            generateProjectBtn: document.getElementById('generate-project'),
            projectFontListContainer: document.getElementById('project-font-list-container'),
            projectFileList: document.getElementById('project-file-list'),
            downloadProjectBtn: document.getElementById('download-project-btn'),
            previewDocumentationBtn: document.getElementById('preview-documentation-btn'),
            newProjectBtn: document.getElementById('new-project-btn'),
            
            // PPT classification elements
            pptClassificationQuestionsContainer: document.getElementById('ppt-classification-questions-container'),
            pptClassificationProgressFill: document.getElementById('ppt-classification-progress-fill'),
            finishPptClassificationBtn: document.getElementById('finish-ppt-classification-btn')
        };

        // Gemini API Configuration - Fixed with correct endpoint
        const GEMINI_API_ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent';

        // Initialize Three.js Background
        function initThreeBackground() {
            const container = document.getElementById('three-background');
            
            // Scene
            const scene = new THREE.Scene();
            
            // Camera
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // Renderer
            const renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);
            
            // Create floating particles
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCount = 500;
            const posArray = new Float32Array(particlesCount * 3);
            
            for(let i = 0; i < particlesCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 10;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            // Material
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.02,
                color: 0x3498db,
                transparent: true,
                opacity: 0.8
            });
            
            // Mesh
            const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particlesMesh);
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Animation
            function animate() {
                requestAnimationFrame(animate);
                
                particlesMesh.rotation.x += 0.001;
                particlesMesh.rotation.y += 0.002;
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Network Status Management
        function updateNetworkStatus() {
            appState.isOnline = navigator.onLine;
            
            if (appState.isOnline) {
                elements.networkStatus.classList.remove('offline');
                elements.networkStatus.classList.add('online');
                elements.networkStatusText.textContent = 'Online';
            } else {
                elements.networkStatus.classList.remove('online');
                elements.networkStatus.classList.add('offline');
                elements.networkStatusText.textContent = 'Offline';
            }
        }

        // Service Worker Registration for Offline Support
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                // Create a simple service worker inline
                const swCode = `
                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open('hope-int-core-v1').then(cache => {
                                return cache.addAll([
                                    '/',
                                    'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
                                    'https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js',
                                    'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js',
                                    'https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js',
                                    'https://assets4.lottiefiles.com/packages/lf20_DMgKk1.json',
                                    'https://assets9.lottiefiles.com/packages/lf20_DMgKk1.json',
                                    'https://assets4.lottiefiles.com/packages/lf20_fcfjwiyb.json',
                                    'https://i.ibb.co/fY5w6PhH/Whats-App-Image-2025-09-28-at-11-58-35-PM.jpg'
                                ]);
                            })
                        );
                    });
                    
                    self.addEventListener('fetch', event => {
                        event.respondWith(
                            caches.match(event.request).then(response => {
                                return response || fetch(event.request);
                            })
                        );
                    });
                `;
                
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);
                
                navigator.serviceWorker.register(swUrl)
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            }
        }

        // Initialize Application
        function initApp() {
            // Register service worker for offline support
            registerServiceWorker();
            
            // Initialize network status
            updateNetworkStatus();
            window.addEventListener('online', updateNetworkStatus);
            window.addEventListener('offline', updateNetworkStatus);
            
            // Show splash screen first
            elements.continueToApp.addEventListener('click', () => {
                elements.splashScreen.style.opacity = '0';
                setTimeout(() => {
                    elements.splashScreen.style.display = 'none';
                    // Initialize Three.js background after splash screen
                    initThreeBackground();
                    
                    // Check if user has seen tutorial
                    const hasSeenTutorial = localStorage.getItem('hasSeenTutorial');
                    if (hasSeenTutorial) {
                        // Check for existing API key
                        const savedApiKey = localStorage.getItem('geminiApiKey');
                        if (savedApiKey) {
                            appState.apiKey = savedApiKey;
                            elements.apiKeyInput.value = savedApiKey;
                            showSection('mainOptions');
                            loadHistory();
                        } else {
                            showSection('apiKey');
                        }
                    } else {
                        // First time user, show tutorial
                        showSection('tutorial');
                    }
                }, 1000);
            });

            // Event Listeners
            elements.saveApiKeyBtn.addEventListener('click', saveApiKey);
            elements.generateQuestionsBtn.addEventListener('click', generatePptClassificationQuestions);
            elements.generatePresentationBtn.addEventListener('click', generatePresentation);
            elements.previewBtn.addEventListener('click', previewPresentation);
            elements.downloadPptBtn.addEventListener('click', downloadPresentation);
            elements.newPresentationBtn.addEventListener('click', resetForNewPresentation);
            elements.clearHistoryBtn.addEventListener('click', clearHistory);
            elements.newCreationFromHistoryBtn.addEventListener('click', () => {
                showSection('mainOptions');
            });
            elements.historyToggle.addEventListener('click', () => {
                if (sections.history.classList.contains('active')) {
                    // If currently showing history, go back to main options
                    showSection('mainOptions');
                } else {
                    // Show history section
                    loadHistory();
                    showSection('history');
                }
            });

            // Tutorial navigation
            elements.gotItBtn.addEventListener('click', () => {
                localStorage.setItem('hasSeenTutorial', 'true');
                showSection('apiKey');
            });

            elements.showTutorialBtn.addEventListener('click', () => {
                showSection('tutorial');
            });
            
            // Main options navigation
            elements.createPptCard.addEventListener('click', () => {
                if (!appState.isOnline) {
                    showNotification('You are currently offline. You can only view previously created presentations.', 'warning');
                    return;
                }
                showSection('topic');
            });
            
            elements.createReportCard.addEventListener('click', () => {
                if (!appState.isOnline) {
                    showNotification('You are currently offline. You can only view previously created reports.', 'warning');
                    return;
                }
                showSection('reportTopic');
            });
            
            elements.createAssignmentCard.addEventListener('click', () => {
                if (!appState.isOnline) {
                    showNotification('You are currently offline. You can only view previously created assignments.', 'warning');
                    return;
                }
                showSection('assignmentTopic');
            });
            
            elements.createProjectCard.addEventListener('click', () => {
                if (!appState.isOnline) {
                    showNotification('You are currently offline. You can only view previously created projects.', 'warning');
                    return;
                }
                showSection('projectTopic');
            });
            
            // Report flow event listeners
            elements.generateClassificationQuestionsBtn.addEventListener('click', generateClassificationQuestions);
            elements.finishClassificationBtn.addEventListener('click', finishClassificationQuestions);
            elements.generateReportBtn.addEventListener('click', generateReport);
            elements.previewReportBtn.addEventListener('click', previewReport);
            elements.downloadReportBtn.addEventListener('click', downloadReportAsPDF);
            elements.newReportBtn.addEventListener('click', resetForNewReport);
            
            // Assignment flow event listeners
            elements.generateAssignmentClassificationQuestionsBtn.addEventListener('click', generateAssignmentClassificationQuestions);
            elements.finishAssignmentClassificationBtn.addEventListener('click', finishAssignmentClassificationQuestions);
            elements.generateAssignmentBtn.addEventListener('click', generateAssignment);
            elements.previewAssignmentBtn.addEventListener('click', previewAssignment);
            elements.downloadAssignmentBtn.addEventListener('click', downloadAssignmentAsPDF);
            elements.newAssignmentBtn.addEventListener('click', resetForNewAssignment);
            
            // Project flow event listeners
            elements.generateProjectClassificationQuestionsBtn.addEventListener('click', generateProjectClassificationQuestions);
            elements.finishProjectClassificationBtn.addEventListener('click', finishProjectClassificationQuestions);
            elements.generateProjectBtn.addEventListener('click', generateProject);
            elements.downloadProjectBtn.addEventListener('click', downloadProject);
            elements.previewDocumentationBtn.addEventListener('click', previewDocumentation);
            elements.newProjectBtn.addEventListener('click', resetForNewProject);
            
            // PPT classification flow event listeners
            elements.finishPptClassificationBtn.addEventListener('click', finishPptClassificationQuestions);

            // Language search functionality
            elements.languageSearch.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                renderLanguageList(searchTerm);
            });
        }

        // Section Navigation
        function showSection(sectionName) {
            Object.values(sections).forEach(section => {
                section.classList.remove('active');
            });
            sections[sectionName].classList.add('active');
        }

        // API Key Management
        function saveApiKey() {
            const apiKey = elements.apiKeyInput.value.trim();
            if (!apiKey) {
                showNotification('Please enter a valid API key', 'error');
                return;
            }

            // Simple validation - check if it looks like a Gemini API key
            if (!apiKey.startsWith('AIza') || apiKey.length < 20) {
                showNotification('Invalid API key format', 'error');
                return;
            }

            appState.apiKey = apiKey;
            localStorage.setItem('geminiApiKey', apiKey);
            elements.apiStatus.textContent = 'API Key saved successfully!';
            elements.apiStatus.style.color = '#3498db';
            
            // Show loading screen then proceed to main options
            showSection('loading');
            setTimeout(() => {
                showSection('mainOptions');
                loadHistory();
            }, 3000);
        }

        // Gemini API Call Function - Fixed with proper error handling
        async function callGeminiAPI(prompt) {
            try {
                // Check if online
                if (!appState.isOnline) {
                    throw new Error('You are currently offline. Please check your internet connection and try again.');
                }
                
                // Validate API key
                if (!appState.apiKey || appState.apiKey.length < 20) {
                    throw new Error('Invalid or missing API key. Please check your API key and try again.');
                }

                const response = await fetch(`${GEMINI_API_ENDPOINT}?key=${appState.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [
                            {
                                parts: [
                                    {
                                        text: prompt
                                    }
                                ]
                            }
                        ],
                        generationConfig: {
                            temperature: 0.7,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 8192,
                        }
                    })
                });

                // Check if response is ok
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    const errorMessage = errorData.error?.message || errorData.error?.details || `HTTP ${response.status}: ${response.statusText}`;
                    
                    // Handle specific error cases
                    if (response.status === 400) {
                        if (errorMessage.includes('API key')) {
                            throw new Error('Invalid API key. Please check your API key and try again.');
                        } else if (errorMessage.includes('quota')) {
                            throw new Error('API quota exceeded. Please try again later or check your billing settings.');
                        } else {
                            throw new Error(`Bad request: ${errorMessage}`);
                        }
                    } else if (response.status === 403) {
                        throw new Error('Access forbidden. Please check your API key permissions.');
                    } else if (response.status === 429) {
                        throw new Error('Too many requests. Please wait a moment and try again.');
                    } else if (response.status >= 500) {
                        throw new Error('Server error. Please try again later.');
                    } else {
                        throw new Error(errorMessage);
                    }
                }

                const data = await response.json();
                
                // Check if response has the expected structure
                if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                    throw new Error('Invalid response format from API');
                }

                const content = data.candidates[0].content;
                
                // Check if content has parts
                if (!content.parts || !content.parts[0] || !content.parts[0].text) {
                    throw new Error('No content received from API');
                }

                return content.parts[0].text;
            } catch (error) {
                console.error('Gemini API Error:', error);
                
                // Re-throw with more user-friendly message
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    throw new Error('Network error. Please check your internet connection and try again.');
                } else if (error.name === 'AbortError') {
                    throw new Error('Request timed out. Please try again.');
                } else {
                    throw error;
                }
            }
        }

        // Generate PPT Classification Questions
        async function generatePptClassificationQuestions() {
            const topic = elements.presentationTopic.value.trim();
            if (!topic) {
                showNotification('Please enter a presentation topic', 'error');
                return;
            }

            appState.topic = topic;
            elements.generateQuestionsBtn.disabled = true;
            elements.generateQuestionsBtn.textContent = 'Generating questions...';
            
            // Show generating animation
            showSection('generatingPptClassification');
            
            try {
                // Build the prompt to generate classification questions with strict formatting instructions
                const prompt = `Based on the topic "${topic}", generate 3-5 specific classification questions that would help gather more information about what kind of presentation the user wants. These questions should help narrow down the focus, scope, and specific aspects of the presentation.

For each question, provide 3-4 multiple choice options.

IMPORTANT: You must return the response in valid JSON format exactly as shown below, with no additional text, explanations, or markdown formatting:

{
  "questions": [
    {
      "question": "Question text here",
      "options": ["Option 1", "Option 2", "Option 3", "Option 4"]
    },
    {
      "question": "Another question here",
      "options": ["Option A", "Option B", "Option C"]
    }
  ]
}

Do not include any text before or after the JSON. The response must be pure JSON that can be parsed by JSON.parse().`;
                
                const response = await callGeminiAPI(prompt);
                
                // Try to parse the JSON response
                let data;
                try {
                    // Clean the response - remove any markdown code blocks or extra text
                    let cleanResponse = response.trim();
                    if (cleanResponse.startsWith('```json')) {
                        cleanResponse = cleanResponse.replace(/```json\n?/, '').replace(/\n?```$/, '');
                    } else if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/```\n?/, '').replace(/\n?```$/, '');
                    }
                    
                    // Try to find JSON object in the response
                    const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        cleanResponse = jsonMatch[0];
                    }
                    
                    data = JSON.parse(cleanResponse);
                    
                    // Validate the structure
                    if (!data.questions || !Array.isArray(data.questions)) {
                        throw new Error('Invalid JSON structure');
                    }
                    
                    // Validate each question
                    data.questions = data.questions.filter(q => 
                        q.question && q.options && Array.isArray(q.options) && q.options.length >= 2
                    );
                    
                    if (data.questions.length === 0) {
                        throw new Error('No valid questions found');
                    }
                    
                    // Limit to 5 questions
                    if (data.questions.length > 5) {
                        data.questions = data.questions.slice(0, 5);
                    }
                    
                    appState.pptClassificationQuestions = data.questions;
                } catch (parseError) {
                    console.error('Failed to parse AI response:', parseError);
                    console.log('Using fallback questions');
                    
                    // Use fallback questions - take first 5
                    appState.pptClassificationQuestions = fallbackPptClassificationQuestions.slice(0, 5);
                    showNotification('Using default questions due to AI response format issue', 'error');
                }
                
                // Initialize answers array
                appState.pptClassificationAnswers = new Array(appState.pptClassificationQuestions.length).fill('');
                appState.currentPptClassificationQuestionIndex = 0;
                
                // Show the PPT classification questions section
                showSection('pptClassificationQuestions');
                renderCurrentPptClassificationQuestion();
            } catch (error) {
                showNotification(`Error generating classification questions: ${error.message}`, 'error');
                elements.generateQuestionsBtn.disabled = false;
                elements.generateQuestionsBtn.textContent = 'Generate Questions';
                showSection('topic');
            }
        }

        // Render Current PPT Classification Question
        function renderCurrentPptClassificationQuestion() {
            const progress = ((appState.currentPptClassificationQuestionIndex + 1) / appState.pptClassificationQuestions.length) * 100;
            elements.pptClassificationProgressFill.style.width = `${progress}%`;
            
            const currentQuestion = appState.pptClassificationQuestions[appState.currentPptClassificationQuestionIndex];
            const selectedOption = appState.pptClassificationAnswers[appState.currentPptClassificationQuestionIndex];
            
            elements.pptClassificationQuestionsContainer.innerHTML = `
                <div class="question-container">
                    <h3>Classification Question ${appState.currentPptClassificationQuestionIndex + 1} of ${appState.pptClassificationQuestions.length}</h3>
                    <p>${currentQuestion.question}</p>
                    <div class="option-container">
                        ${currentQuestion.options.map((option, index) => `
                            <label class="option ${selectedOption === option ? 'selected' : ''}">
                                <input type="radio" name="ppt-classification-question-${appState.currentPptClassificationQuestionIndex}" value="${option}" ${selectedOption === option ? 'checked' : ''}>
                                ${option}
                            </label>
                        `).join('')}
                    </div>
                    <div style="margin-top: 15px;">
                        ${appState.currentPptClassificationQuestionIndex > 0 ? '<button id="prev-ppt-classification-question-btn">Previous</button>' : ''}
                        ${appState.currentPptClassificationQuestionIndex < appState.pptClassificationQuestions.length - 1 ? '<button id="next-ppt-classification-question-btn">Next</button>' : '<button id="finish-ppt-classification-btn">Continue to Presentation Options</button>'}
                    </div>
                </div>
            `;
            
            // Add event listeners for options
            const optionElements = document.querySelectorAll('.option');
            optionElements.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    optionElements.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the answer
                    const input = option.querySelector('input');
                    input.checked = true;
                    // Store the answer
                    appState.pptClassificationAnswers[appState.currentPptClassificationQuestionIndex] = input.value;
                });
            });
            
            if (appState.currentPptClassificationQuestionIndex > 0) {
                document.getElementById('prev-ppt-classification-question-btn').addEventListener('click', previousPptClassificationQuestion);
            }
            
            if (appState.currentPptClassificationQuestionIndex < appState.pptClassificationQuestions.length - 1) {
                document.getElementById('next-ppt-classification-question-btn').addEventListener('click', nextPptClassificationQuestion);
            } else {
                document.getElementById('finish-ppt-classification-btn').addEventListener('click', finishPptClassificationQuestions);
            }
        }

        // PPT Classification Question Navigation
        function nextPptClassificationQuestion() {
            appState.currentPptClassificationQuestionIndex++;
            renderCurrentPptClassificationQuestion();
        }

        function previousPptClassificationQuestion() {
            appState.currentPptClassificationQuestionIndex--;
            renderCurrentPptClassificationQuestion();
        }

        function finishPptClassificationQuestions() {
            // Check if all questions have answers
            const allAnswered = appState.pptClassificationAnswers.every(answer => answer.trim() !== '');
            if (!allAnswered) {
                showNotification('Please answer all classification questions before proceeding', 'error');
                return;
            }
            
            // Now proceed to the presentation customization questions
            generatePresentationQuestions();
        }

        // Generate Presentation Questions
        function generatePresentationQuestions() {
            elements.generateQuestionsBtn.disabled = true;
            elements.generateQuestionsBtn.textContent = 'Preparing questions...';
            
            // Set predefined questions for the presentation
            appState.questions = [
                {
                    question: "What language do you want for your presentation?",
                    options: ["Malayalam", "English", "Other"],
                    variable: "language"
                },
                {
                    question: "What presentation style do you prefer?",
                    options: ["Professional Corporate", "Creative Modern", "Minimalist Clean", "Bold Impactful", "Academic Formal"],
                    variable: "presentationStyle"
                },
                {
                    question: "What theme do you prefer?",
                    options: ["Minimal", "Creative", "Professional", "HighTech", "Corporate", "Academic", "Modern", "Vintage"],
                    variable: "theme"
                },
                {
                    question: "How many slides do you want?",
                    options: ["1-4", "1-6", "1-8", "1-10", "1-12", "1-15"],
                    variable: "slideCount"
                },
                {
                    question: "What structure do you prefer for each slide?",
                    options: ["Title and content", "Title and bullet points", "Title, subtitle and content", "Title, subtitle and bullet points", "Two-column layout", "Three-column layout"],
                    variable: "structure"
                },
                {
                    question: "What animation style do you prefer?",
                    options: ["Simple transitions (fade, slide)", "Advanced animations (rotate, zoom, bounce)", "3D animations (flip, cube, carousel)", "No animation"],
                    variable: "animationStyle"
                },
                {
                    question: "What level of 3D elements do you want?",
                    options: ["None", "Basic 3D shapes", "Advanced 3D models", "Interactive 3D elements"],
                    variable: "advancedAnimations"
                },
                {
                    question: "What interactive elements do you want?",
                    options: ["None", "Basic (click to reveal)", "Advanced (drag, zoom, rotate)", "Interactive quizzes", "Interactive simulations"],
                    variable: "interactiveElements"
                },
                {
                    question: "Do you want data visualization?",
                    options: ["No", "Yes, basic charts", "Yes, advanced charts", "Yes, interactive charts"],
                    variable: "dataVisualization"
                },
                {
                    question: "Do you want multimedia elements?",
                    options: ["No", "Audio only", "Video only", "Both audio and video"],
                    variable: "multimediaElements"
                },
                {
                    question: "What type of images do you want?",
                    options: ["No images", "Icons only", "SVG graphics only", "Photographs only", "Mix of icons and SVG graphics", "Mix of SVG graphics and photographs", "Mix of all types"],
                    variable: "includeImages"
                },
                {
                    question: "What image fallback strategy do you prefer?",
                    options: ["No fallback", "Text description fallback", "Placeholder image fallback", "Both text and placeholder fallback"],
                    variable: "imageFallback"
                },
                {
                    question: "What color theme do you prefer?",
                    options: ["Black and white with blue accent", "Black and white with green accent", "Black and white with red accent", "Black and white with purple accent", "Dark theme with blue", "Dark theme with green", "Dark theme with red", "Dark theme with purple", "Light theme with blue", "Light theme with green", "Light theme with red", "Light theme with purple", "Custom color (select two)"],
                    variable: "colorTheme"
                },
                {
                    question: "Content Depth Preference?",
                    options: ["Beginner level", "Intermediate level", "Expert level", "Mixed levels"],
                    variable: "termsdepth"
                },
                {
                    question: "How long should descriptions be?",
                    options: ["Very short (1 sentence)", "Short (2-3 sentences)", "Medium (4-5 sentences)", "Long (6-7 sentences)", "Very long (8+ sentences)"],
                    variable: "descriptionLength"
                },
                {
                    question: "How many bullet points per slide?",
                    options: ["1-2", "3-4", "5-6", "7-8", "9-10"],
                    variable: "bulletPointsCount"
                },
                {
                    question: "What font size do you prefer?",
                    options: ["Very small", "Small", "Medium", "Large", "Very large"],
                    variable: "fontSize"
                },
                {
                    question: "Which 3D background do you prefer?",
                    options: ["Stars in Universe", "3D nodes", "3D floating particles", "Abstract shapes", "3D landscape", "3D cityscape", "3D underwater", "3D space nebula", "No background"],
                    variable: "bgitem"
                }
            ];
            
            // Initialize answers array for these questions
            appState.answers = new Array(appState.questions.length).fill('');
            appState.currentQuestionIndex = 0;
            
            // Show the questions section
            showSection('questions');
            renderCurrentQuestion();
        }

        // Render Current Question with Options
        function renderCurrentQuestion() {
            const progress = ((appState.currentQuestionIndex + 1) / appState.questions.length) * 100;
            elements.progressFill.style.width = `${progress}%`;
            
            const currentQuestion = appState.questions[appState.currentQuestionIndex];
            const selectedOption = appState.answers[appState.currentQuestionIndex];
            
            elements.questionsContainer.innerHTML = `
                <div class="question-container">
                    <h3>Question ${appState.currentQuestionIndex + 1} of ${appState.questions.length}</h3>
                    <p>${currentQuestion.question}</p>
                    <div class="option-container">
                        ${currentQuestion.options.map((option, index) => `
                            <label class="option ${selectedOption === option ? 'selected' : ''}">
                                <input type="radio" name="question-${appState.currentQuestionIndex}" value="${option}" ${selectedOption === option ? 'checked' : ''}>
                                ${option}
                            </label>
                        `).join('')}
                    </div>
                    <div style="margin-top: 15px;">
                        ${appState.currentQuestionIndex > 0 ? '<button id="prev-question-btn">Previous</button>' : ''}
                        ${appState.currentQuestionIndex < appState.questions.length - 1 ? '<button id="next-question-btn">Next</button>' : '<button id="finish-questions-btn">Finish</button>'}
                    </div>
                </div>
            `;
            
            // Show custom color pickers if color theme question and custom option is selected
            if (currentQuestion.variable === "colorTheme" && selectedOption === "Custom color (select two)") {
                elements.customColorsContainer.classList.add('show');
            } else {
                elements.customColorsContainer.classList.remove('show');
            }
            
            // Show language dropdown if language question and "Other" option is selected
            if (currentQuestion.variable === "language" && selectedOption === "Other") {
                elements.languageDropdownContainer.classList.add('show');
                renderLanguageList();
            } else {
                elements.languageDropdownContainer.classList.remove('show');
            }
            
            // Add event listeners for options
            const optionElements = document.querySelectorAll('.option');
            optionElements.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    optionElements.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the answer
                    const input = option.querySelector('input');
                    input.checked = true;
                    // Store the answer in appState using the variable name
                    const variableName = appState.questions[appState.currentQuestionIndex].variable;
                    appState[variableName] = input.value;
                    // Also update the answers array for progress tracking
                    appState.answers[appState.currentQuestionIndex] = input.value;
                    
                    // Show/hide custom color pickers based on selection
                    if (variableName === "colorTheme" && input.value === "Custom color (select two)") {
                        elements.customColorsContainer.classList.add('show');
                    } else {
                        elements.customColorsContainer.classList.remove('show');
                    }
                    
                    // Show/hide language dropdown based on selection
                    if (variableName === "language" && input.value === "Other") {
                        elements.languageDropdownContainer.classList.add('show');
                        renderLanguageList();
                    } else {
                        elements.languageDropdownContainer.classList.remove('show');
                    }
                });
            });
            
            // Add event listeners for color pickers
            const colorPicker1 = document.getElementById('custom-color-1');
            const colorPicker2 = document.getElementById('custom-color-2');
            const colorCode1 = document.getElementById('color-code-1');
            const colorCode2 = document.getElementById('color-code-2');
            
            if (colorPicker1) {
                colorPicker1.addEventListener('input', (e) => {
                    appState.customColor1 = e.target.value;
                    colorCode1.textContent = e.target.value;
                });
            }
            
            if (colorPicker2) {
                colorPicker2.addEventListener('input', (e) => {
                    appState.customColor2 = e.target.value;
                    colorCode2.textContent = e.target.value;
                });
            }
            
            if (appState.currentQuestionIndex > 0) {
                document.getElementById('prev-question-btn').addEventListener('click', previousQuestion);
            }
            
            if (appState.currentQuestionIndex < appState.questions.length - 1) {
                document.getElementById('next-question-btn').addEventListener('click', nextQuestion);
            } else {
                document.getElementById('finish-questions-btn').addEventListener('click', finishQuestions);
            }
        }

        // Render Language List
        function renderLanguageList(searchTerm = '') {
            const filteredLanguages = languages.filter(lang => 
                lang.toLowerCase().includes(searchTerm.toLowerCase())
            );
            
            elements.languageList.innerHTML = filteredLanguages.map(lang => `
                <div class="language-option ${appState.language === lang ? 'selected' : ''}" data-lang="${lang}">
                    ${lang}
                </div>
            `).join('');
            
            // Add event listeners to language options
            const languageOptions = document.querySelectorAll('.language-option');
            languageOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    languageOptions.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the selected language
                    appState.language = option.dataset.lang;
                    // Update the answer in the answers array
                    appState.answers[appState.currentQuestionIndex] = appState.language;
                });
            });
        }

        // Question Navigation
        function nextQuestion() {
            appState.currentQuestionIndex++;
            renderCurrentQuestion();
        }

        function previousQuestion() {
            appState.currentQuestionIndex--;
            renderCurrentQuestion();
        }

        function finishQuestions() {
            // Check if all questions have answers
            const allAnswered = appState.answers.every(answer => answer.trim() !== '');
            if (!allAnswered) {
                showNotification('Please answer all questions before proceeding', 'error');
                return;
            }
            
            // Check if custom color option is selected and validate colors
            if (appState.colorTheme === "Custom color (select two)") {
                if (!appState.customColor1 || !appState.customColor2) {
                    showNotification('Please select both custom colors', 'error');
                    return;
                }
            }
            
            // Check if language is "Other" and no specific language is selected
            if (appState.language === "Other" && !appState.selectedLanguage) {
                showNotification('Please select a specific language', 'error');
                return;
            }
            
            elements.generatePresentationBtn.disabled = false;
            showNotification('All questions answered. You can now generate your presentation!');
        }

        // Presentation Generation - Updated to include classification answers
        async function generatePresentation() {
            elements.generatePresentationBtn.disabled = true;
            elements.generatePresentationBtn.textContent = 'Generating presentation...';
            
            // Show generating animation
            showSection('generating');
            
            try {
                // Extract the parameters from appState
                const { 
                    topic, 
                    theme, 
                    slideCount, 
                    structure, 
                    animationStyle, 
                    colorTheme, 
                    customColor1, 
                    customColor2, 
                    bgitem, 
                    termsdepth,
                    descriptionLength,
                    bulletPointsCount,
                    fontSize,
                    includeImages,
                    imageFallback,
                    language,
                    presentationStyle,
                    advancedAnimations,
                    interactiveElements,
                    dataVisualization,
                    multimediaElements,
                    pptClassificationQuestions,
                    pptClassificationAnswers
                } = appState;
                
                // Determine the actual language to use
                let presentationLanguage = language;
                if (language === "Other") {
                    presentationLanguage = appState.selectedLanguage || "English";
                }
                
                // Build the color theme string for the prompt
                let colorThemeString;
                if (colorTheme === "Custom color (select two)") {
                    colorThemeString = `Custom colors: ${customColor1} and ${customColor2}`;
                } else {
                    colorThemeString = colorTheme;
                }
                
                // Build classification information string
                let classificationInfo = '';
                for (let i = 0; i < pptClassificationQuestions.length; i++) {
                    classificationInfo += `Q: ${pptClassificationQuestions[i].question}\nA: ${pptClassificationAnswers[i]}\n\n`;
                }
                
                // Build the prompt
                const prompt = `Create a complete HTML, CSS, and JavaScript file for a presentation about "${topic}". 

The user has provided the following additional classification information:
 ${classificationInfo}

The presentation should have the following features:

1. Fullscreen functionality: When the user presses the 'F' key, the presentation should enter fullscreen mode.
2. Navigation: Include arrow key navigation (left and right arrows) to move between slides in both directions.
3. Design: Use clean, professional designs with glassmorphism UI elements. The UI should have a glass-like appearance with backdrop blur effects.
4. Color scheme: Use colors suitable for the topic "${topic}". Apply the selected color theme: "${colorThemeString}".
5. 3D theme background: Slide should have a Three.js 3D background as "${bgitem}".
6. Content depth: Use "${termsdepth}" for the content language style.
7. Animations: Use CSS for all animations. The animation style should be "${animationStyle}".
8. Structure: Each slide should follow the "${structure}" format.
9. Theme: The overall theme should be "${theme}".
10. Slide count: Create ${slideCount} slides with well-organized content.
11. Description length: For slides with paragraphs, use ${descriptionLength}.
12. Bullet points: For slides with bullet points, include ${bulletPointsCount} bullet points per slide.
13. Font size: Use ${fontSize} font size throughout the presentation.
14. Images: ${includeImages}. For SVG graphics, use inline SVG code for crisp rendering at any size.
15. Image fallback: ${imageFallback}. Implement proper fallback mechanisms for images that fail to load.
16. Language: Generate the entire presentation in ${presentationLanguage}. All text content, including headings, paragraphs, and bullet points, must be in ${presentationLanguage}.
17. Presentation style: The presentation should follow a "${presentationStyle}" approach.
18. 3D elements: Include ${advancedAnimations} in the slides.
19. Interactive elements: Implement ${interactiveElements} for user engagement.
20. Data visualization: ${dataVisualization} should be included where appropriate.
21. Multimedia elements: ${multimediaElements} should be incorporated into the presentation.

Additional requirements:
- Include slide indicators (dots) at the bottom to show current slide position.
- Add Previous/Next buttons for navigation.
- Make the presentation responsive for different screen sizes.
- Use semantic HTML5 tags throughout.
- Add smooth transitions between slides.
- Include professional typography with clear hierarchy.
- For SVG images, use inline SVG code with proper viewBox attributes for scalability.
- Implement image fallback strategies: ${imageFallback}. For text fallbacks, use descriptive alt text. For placeholder fallbacks, use a placeholder image with a message indicating the image could not be loaded.

The presentation should be structured as follows:
1. Title slide with the topic "${topic}" and a subtitle.
2. Introduction slide explaining key concepts.
3. Main content slides with detailed information.
4. Conclusion slide with key takeaways.

3D theme background: Slide should have a Three.js 3D background as "${bgitem}".
Return only the complete HTML code without any additional explanations.`;
                
                const presentationHTML = await callGeminiAPI(prompt);
                
                // Ensure watermark is present
                const finalHTML = ensureWatermark(presentationHTML);
                
                appState.generatedPresentation = finalHTML;
                
                // Save to history
                saveToHistory(appState.topic, finalHTML, 'presentation');
                
                // Show preview section
                showSection('preview');
            } catch (error) {
                showNotification(`Error generating presentation: ${error.message}`, 'error');
                elements.generatePresentationBtn.disabled = false;
                elements.generatePresentationBtn.textContent = 'Generate Presentation';
                showSection('questions');
            }
        }

        // Ensure watermark is present in the presentation
        function ensureWatermark(html) {
            // Check if watermark is already present
            if (html.includes('Developed under HOPE Research Team') && html.includes('By Justin')) {
                return html;
            }
            
            // Find each slide and add watermark if not present
            const slidePattern = /<div class="slide-content">(.*?)<\/div>/gs;
            const watermark = '<div class="watermark">Developed under HOPE Research Team<br> by Justin</div>';
            
            return html.replace(slidePattern, (match, content) => {
                if (!content.includes('watermark')) {
                    return `<div class="slide-content">${content}${watermark}</div>`;
                }
                return match;
            });
        }

        // Preview Function
        function previewPresentation() {
            const newWindow = window.open();
            newWindow.document.write(appState.generatedPresentation);
            newWindow.document.close();
        }

        // Download Presentation as HTML
        function downloadPresentation() {
            const blob = new Blob([appState.generatedPresentation], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${appState.topic.replace(/\s+/g, '_')}_presentation.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification('Presentation downloaded successfully!');
        }

        // Generate Classification Questions
        async function generateClassificationQuestions() {
            const topic = elements.reportTopicInput.value.trim();
            if (!topic) {
                showNotification('Please enter a report topic', 'error');
                return;
            }

            appState.reportTopic = topic;
            elements.generateClassificationQuestionsBtn.disabled = true;
            elements.generateClassificationQuestionsBtn.textContent = 'Generating questions...';
            
            // Show generating animation
            showSection('generatingClassification');
            
            try {
                // Build the prompt to generate classification questions with strict formatting instructions
                const prompt = `Based on the topic "${topic}", generate 3-5 specific classification questions that would help gather more information about what kind of report the user wants. These questions should help narrow down the focus, scope, and specific aspects of the topic.

For each question, provide 3-4 multiple choice options.

IMPORTANT: You must return the response in valid JSON format exactly as shown below, with no additional text, explanations, or markdown formatting:

{
  "questions": [
    {
      "question": "Question text here",
      "options": ["Option 1", "Option 2", "Option 3", "Option 4"]
    },
    {
      "question": "Another question here",
      "options": ["Option A", "Option B", "Option C"]
    }
  ]
}

Do not include any text before or after the JSON. The response must be pure JSON that can be parsed by JSON.parse().`;
                
                const response = await callGeminiAPI(prompt);
                
                // Try to parse the JSON response
                let data;
                try {
                    // Clean the response - remove any markdown code blocks or extra text
                    let cleanResponse = response.trim();
                    if (cleanResponse.startsWith('```json')) {
                        cleanResponse = cleanResponse.replace(/```json\n?/, '').replace(/\n?```$/, '');
                    } else if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/```\n?/, '').replace(/\n?```$/, '');
                    }
                    
                    // Try to find JSON object in the response
                    const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        cleanResponse = jsonMatch[0];
                    }
                    
                    data = JSON.parse(cleanResponse);
                    
                    // Validate the structure
                    if (!data.questions || !Array.isArray(data.questions)) {
                        throw new Error('Invalid JSON structure');
                    }
                    
                    // Validate each question
                    data.questions = data.questions.filter(q => 
                        q.question && q.options && Array.isArray(q.options) && q.options.length >= 2
                    );
                    
                    if (data.questions.length === 0) {
                        throw new Error('No valid questions found');
                    }
                    
                    // Limit to 5 questions
                    if (data.questions.length > 5) {
                        data.questions = data.questions.slice(0, 5);
                    }
                    
                    appState.classificationQuestions = data.questions;
                } catch (parseError) {
                    console.error('Failed to parse AI response:', parseError);
                    console.log('Using fallback questions');
                    
                    // Use fallback questions - take first 5
                    appState.classificationQuestions = fallbackClassificationQuestions.slice(0, 5);
                    showNotification('Using default questions due to AI response format issue', 'error');
                }
                
                // Initialize answers array
                appState.classificationAnswers = new Array(appState.classificationQuestions.length).fill('');
                appState.currentClassificationQuestionIndex = 0;
                
                // Show the classification questions section
                showSection('classificationQuestions');
                renderCurrentClassificationQuestion();
            } catch (error) {
                showNotification(`Error generating classification questions: ${error.message}`, 'error');
                elements.generateClassificationQuestionsBtn.disabled = false;
                elements.generateClassificationQuestionsBtn.textContent = 'Next';
                showSection('reportTopic');
            }
        }

        // Render Current Classification Question
        function renderCurrentClassificationQuestion() {
            const progress = ((appState.currentClassificationQuestionIndex + 1) / appState.classificationQuestions.length) * 100;
            elements.classificationProgressFill.style.width = `${progress}%`;
            
            const currentQuestion = appState.classificationQuestions[appState.currentClassificationQuestionIndex];
            const selectedOption = appState.classificationAnswers[appState.currentClassificationQuestionIndex];
            
            elements.classificationQuestionsContainer.innerHTML = `
                <div class="question-container">
                    <h3>Classification Question ${appState.currentClassificationQuestionIndex + 1} of ${appState.classificationQuestions.length}</h3>
                    <p>${currentQuestion.question}</p>
                    <div class="option-container">
                        ${currentQuestion.options.map((option, index) => `
                            <label class="option ${selectedOption === option ? 'selected' : ''}">
                                <input type="radio" name="classification-question-${appState.currentClassificationQuestionIndex}" value="${option}" ${selectedOption === option ? 'checked' : ''}>
                                ${option}
                            </label>
                        `).join('')}
                    </div>
                    <div style="margin-top: 15px;">
                        ${appState.currentClassificationQuestionIndex > 0 ? '<button id="prev-classification-question-btn">Previous</button>' : ''}
                        ${appState.currentClassificationQuestionIndex < appState.classificationQuestions.length - 1 ? '<button id="next-classification-question-btn">Next</button>' : '<button id="finish-classification-btn">Continue to Report Options</button>'}
                    </div>
                </div>
            `;
            
            // Add event listeners for options
            const optionElements = document.querySelectorAll('.option');
            optionElements.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    optionElements.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the answer
                    const input = option.querySelector('input');
                    input.checked = true;
                    // Store the answer
                    appState.classificationAnswers[appState.currentClassificationQuestionIndex] = input.value;
                });
            });
            
            if (appState.currentClassificationQuestionIndex > 0) {
                document.getElementById('prev-classification-question-btn').addEventListener('click', previousClassificationQuestion);
            }
            
            if (appState.currentClassificationQuestionIndex < appState.classificationQuestions.length - 1) {
                document.getElementById('next-classification-question-btn').addEventListener('click', nextClassificationQuestion);
            } else {
                document.getElementById('finish-classification-btn').addEventListener('click', finishClassificationQuestions);
            }
        }

        // Classification Question Navigation
        function nextClassificationQuestion() {
            appState.currentClassificationQuestionIndex++;
            renderCurrentClassificationQuestion();
        }

        function previousClassificationQuestion() {
            appState.currentClassificationQuestionIndex--;
            renderCurrentClassificationQuestion();
        }

        function finishClassificationQuestions() {
            // Check if all questions have answers
            const allAnswered = appState.classificationAnswers.every(answer => answer.trim() !== '');
            if (!allAnswered) {
                showNotification('Please answer all classification questions before proceeding', 'error');
                return;
            }
            
            // Now proceed to the report customization questions
            generateReportQuestions();
        }

        // Report Topic and Questions - Modified to be called after classification
        function generateReportQuestions() {
            elements.generateClassificationQuestionsBtn.disabled = true;
            elements.generateClassificationQuestionsBtn.textContent = 'Preparing questions...';
            
            // Set predefined questions for the report
            appState.reportQuestions = [
                {
                    question: "What font size do you prefer?",
                    options: ["Normal", "Small", "Big"],
                    variable: "reportFontSize"
                },
                {
                    question: "What font style do you prefer?",
                    options: ["Normal", "Handwritten", "Typewriter", "Other"],
                    variable: "reportFont"
                },
                {
                    question: "What design style do you prefer?",
                    options: ["Normal", "Advanced designs", "Simple designs"],
                    variable: "reportStyle"
                },
                {
                    question: "What elements do you want to include?",
                    options: ["SVG", "Icons", "Images"],
                    variable: "reportElements"
                }
            ];
            
            // Initialize answers array for these questions
            appState.reportAnswers = new Array(appState.reportQuestions.length).fill('');
            appState.currentReportQuestionIndex = 0;
            
            // Show the report questions section
            showSection('reportQuestions');
            renderCurrentReportQuestion();
        }

        // Render Current Report Question
        function renderCurrentReportQuestion() {
            const progress = ((appState.currentReportQuestionIndex + 1) / appState.reportQuestions.length) * 100;
            elements.reportProgressFill.style.width = `${progress}%`;
            
            const currentQuestion = appState.reportQuestions[appState.currentReportQuestionIndex];
            const selectedOption = appState.reportAnswers[appState.currentReportQuestionIndex];
            
            elements.reportQuestionsContainer.innerHTML = `
                <div class="question-container">
                    <h3>Question ${appState.currentReportQuestionIndex + 1} of ${appState.reportQuestions.length}</h3>
                    <p>${currentQuestion.question}</p>
                    <div class="option-container">
                        ${currentQuestion.options.map((option, index) => `
                            <label class="option ${selectedOption === option ? 'selected' : ''}">
                                <input type="radio" name="report-question-${appState.currentReportQuestionIndex}" value="${option}" ${selectedOption === option ? 'checked' : ''}>
                                ${option}
                            </label>
                        `).join('')}
                    </div>
                    <div style="margin-top: 15px;">
                        ${appState.currentReportQuestionIndex > 0 ? '<button id="prev-report-question-btn">Previous</button>' : ''}
                        ${appState.currentReportQuestionIndex < appState.reportQuestions.length - 1 ? '<button id="next-report-question-btn">Next</button>' : '<button id="finish-report-questions-btn">Finish</button>'}
                    </div>
                </div>
            `;
            
            // Show font list if font question and "Other" option is selected
            if (currentQuestion.variable === "reportFont" && selectedOption === "Other") {
                elements.fontListContainer.classList.add('show');
                renderFontList();
            } else {
                elements.fontListContainer.classList.remove('show');
            }
            
            // Add event listeners for options
            const optionElements = document.querySelectorAll('.option');
            optionElements.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    optionElements.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the answer
                    const input = option.querySelector('input');
                    input.checked = true;
                    // Store the answer in appState using the variable name
                    const variableName = appState.reportQuestions[appState.currentReportQuestionIndex].variable;
                    appState[variableName] = input.value;
                    // Also update the answers array for progress tracking
                    appState.reportAnswers[appState.currentReportQuestionIndex] = input.value;
                    
                    // Show/hide font list based on selection
                    if (variableName === "reportFont" && input.value === "Other") {
                        elements.fontListContainer.classList.add('show');
                        renderFontList();
                    } else {
                        elements.fontListContainer.classList.remove('show');
                    }
                });
            });
            
            if (appState.currentReportQuestionIndex > 0) {
                document.getElementById('prev-report-question-btn').addEventListener('click', previousReportQuestion);
            }
            
            if (appState.currentReportQuestionIndex < appState.reportQuestions.length - 1) {
                document.getElementById('next-report-question-btn').addEventListener('click', nextReportQuestion);
            } else {
                document.getElementById('finish-report-questions-btn').addEventListener('click', finishReportQuestions);
            }
        }

        // Render Font List
        function renderFontList() {
            elements.fontListContainer.innerHTML = fonts.map(font => `
                <div class="font-option ${appState.selectedFont === font ? 'selected' : ''}" data-font="${font}">
                    ${font}
                </div>
            `).join('');
            
            // Add event listeners to font options
            const fontOptions = document.querySelectorAll('.font-option');
            fontOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    fontOptions.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the selected font
                    appState.selectedFont = option.dataset.font;
                });
            });
        }

        // Report Question Navigation
        function nextReportQuestion() {
            appState.currentReportQuestionIndex++;
            renderCurrentReportQuestion();
        }

        function previousReportQuestion() {
            appState.currentReportQuestionIndex--;
            renderCurrentReportQuestion();
        }

        function finishReportQuestions() {
            // Check if all questions have answers
            const allAnswered = appState.reportAnswers.every(answer => answer.trim() !== '');
            if (!allAnswered) {
                showNotification('Please answer all questions before proceeding', 'error');
                return;
            }
            
            // Check if font is "Other" and no specific font is selected
            if (appState.reportFont === "Other" && !appState.selectedFont) {
                showNotification('Please select a specific font', 'error');
                return;
            }
            
            elements.generateReportBtn.disabled = false;
            showNotification('All questions answered. You can now generate your report!');
        }

        // Report Generation - Modified to include classification answers
        async function generateReport() {
            elements.generateReportBtn.disabled = true;
            elements.generateReportBtn.textContent = 'Generating report...';
            
            // Show generating animation
            showSection('generatingReport');
            
            try {
                // Extract the parameters from appState
                const { 
                    reportTopic, 
                    reportFontSize, 
                    reportFont, 
                    reportStyle, 
                    reportElements,
                    selectedFont,
                    classificationQuestions,
                    classificationAnswers
                } = appState;
                
                // Determine the actual font to use
                let actualFont = reportFont;
                if (reportFont === "Other") {
                    actualFont = selectedFont || "Arial";
                }
                
                // Build classification information string
                let classificationInfo = '';
                for (let i = 0; i < classificationQuestions.length; i++) {
                    classificationInfo += `Q: ${classificationQuestions[i].question}\nA: ${classificationAnswers[i]}\n\n`;
                }
                
                // Build the prompt
                const prompt = `Create a complete HTML, CSS, and JavaScript file for a printable report about "${reportTopic}". 

The user has provided the following additional classification information:
 ${classificationInfo}

The report should have the following features:

1. Font size: ${reportFontSize}
2. Font style: ${actualFont}
3. Design style: ${reportStyle}
4. Include elements: ${reportElements}

The report should be well-structured with appropriate headings, paragraphs, and possibly lists or tables. Use the classification information to tailor the content to the user's specific needs and interests.

Additionally, include a download button at the top of the page with the id 'download-pdf-btn'. This button should trigger the download of the page as a PDF. Use the following JavaScript for the button:

\`\`\`javascript
document.getElementById('download-pdf-btn').addEventListener('click', function() {
    window.print();
});
\`\`\`

Also, add the following CSS to hide the button when printing:

\`\`\`css
@media print {
    #download-pdf-btn {
        display: none;
    }
}
\`\`\`

The report should be responsive and look good when printed on A4 paper.

Include a watermark at the bottom of each page that says "Developed under HOPE Research Team | by Justin".

Return only the complete HTML code without any additional explanations.`;
                
                const reportHTML = await callGeminiAPI(prompt);
                appState.generatedReport = reportHTML;
                
                // Save to history
                saveToHistory(appState.reportTopic, reportHTML, 'report');
                
                // Show preview section
                showSection('reportPreview');
            } catch (error) {
                showNotification(`Error generating report: ${error.message}`, 'error');
                elements.generateReportBtn.disabled = false;
                elements.generateReportBtn.textContent = 'Generate Report';
                showSection('reportQuestions');
            }
        }

        // Report Preview and Download
        function previewReport() {
            const newWindow = window.open();
            newWindow.document.write(appState.generatedReport);
            newWindow.document.close();
        }

        function downloadReportAsPDF() {
            const newWindow = window.open();
            newWindow.document.write(appState.generatedReport);
            newWindow.document.close();
            
            // Wait for the content to load, then trigger print
            setTimeout(() => {
                newWindow.print();
            }, 1000);
        }

        // Reset for New Report - Modified to reset classification state
        function resetForNewReport() {
            appState.reportTopic = '';
            appState.reportFontSize = '';
            appState.reportFont = '';
            appState.reportStyle = '';
            appState.reportElements = '';
            appState.selectedFont = '';
            appState.reportQuestions = [];
            appState.reportAnswers = [];
            appState.currentReportQuestionIndex = 0;
            appState.classificationQuestions = [];
            appState.classificationAnswers = [];
            appState.currentClassificationQuestionIndex = 0;
            elements.reportTopicInput.value = '';
            showSection('reportTopic');
        }

        // Reset for New Presentation - Modified to reset classification state
        function resetForNewPresentation() {
            appState.topic = '';
            appState.theme = '';
            appState.slideCount = '';
            appState.structure = '';
            appState.animationStyle = '';
            appState.colorTheme = '';
            appState.customColor1 = '#3498db';
            appState.customColor2 = '#e74c3c';
            appState.descriptionLength = '';
            appState.bulletPointsCount = '';
            appState.fontSize = '';
            appState.includeImages = '';
            appState.imageFallback = '';
            appState.language = 'English';
            appState.selectedLanguage = '';
            appState.presentationStyle = '';
            appState.advancedAnimations = '';
            appState.interactiveElements = '';
            appState.dataVisualization = '';
            appState.multimediaElements = '';
            appState.questions = [];
            appState.answers = [];
            appState.currentQuestionIndex = 0;
            appState.pptClassificationQuestions = [];
            appState.pptClassificationAnswers = [];
            appState.currentPptClassificationQuestionIndex = 0;
            elements.presentationTopic.value = '';
            document.getElementById('custom-color-1').value = '#3498db';
            document.getElementById('custom-color-2').value = '#e74c3c';
            document.getElementById('color-code-1').textContent = '#3498db';
            document.getElementById('color-code-2').textContent = '#e74c3c';
            showSection('topic');
        }

        // Assignment Classification Questions Generation
        async function generateAssignmentClassificationQuestions() {
            const topic = elements.assignmentTopicInput.value.trim();
            if (!topic) {
                showNotification('Please enter an assignment topic', 'error');
                return;
            }

            appState.assignmentTopic = topic;
            elements.generateAssignmentClassificationQuestionsBtn.disabled = true;
            elements.generateAssignmentClassificationQuestionsBtn.textContent = 'Generating questions...';
            
            // Show generating animation
            showSection('generatingAssignmentClassification');
            
            try {
                // Build the prompt to generate assignment classification questions with strict formatting instructions
                const prompt = `Based on the topic "${topic}", generate 3-5 specific classification questions that would help gather more information about what kind of assignment the user wants. These questions should help narrow down the focus, scope, and specific aspects of the assignment.

For each question, provide 3-4 multiple choice options.

IMPORTANT: You must return the response in valid JSON format exactly as shown below, with no additional text, explanations, or markdown formatting:

{
  "questions": [
    {
      "question": "Question text here",
      "options": ["Option 1", "Option 2", "Option 3", "Option 4"]
    },
    {
      "question": "Another question here",
      "options": ["Option A", "Option B", "Option C"]
    }
  ]
}

Do not include any text before or after the JSON. The response must be pure JSON that can be parsed by JSON.parse().`;
                
                const response = await callGeminiAPI(prompt);
                
                // Try to parse the JSON response
                let data;
                try {
                    // Clean the response - remove any markdown code blocks or extra text
                    let cleanResponse = response.trim();
                    if (cleanResponse.startsWith('```json')) {
                        cleanResponse = cleanResponse.replace(/```json\n?/, '').replace(/\n?```$/, '');
                    } else if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/```\n?/, '').replace(/\n?```$/, '');
                    }
                    
                    // Try to find JSON object in the response
                    const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        cleanResponse = jsonMatch[0];
                    }
                    
                    data = JSON.parse(cleanResponse);
                    
                    // Validate the structure
                    if (!data.questions || !Array.isArray(data.questions)) {
                        throw new Error('Invalid JSON structure');
                    }
                    
                    // Validate each question
                    data.questions = data.questions.filter(q => 
                        q.question && q.options && Array.isArray(q.options) && q.options.length >= 2
                    );
                    
                    if (data.questions.length === 0) {
                        throw new Error('No valid questions found');
                    }
                    
                    // Limit to 5 questions
                    if (data.questions.length > 5) {
                        data.questions = data.questions.slice(0, 5);
                    }
                    
                    appState.assignmentClassificationQuestions = data.questions;
                } catch (parseError) {
                    console.error('Failed to parse AI response:', parseError);
                    console.log('Using fallback questions');
                    
                    // Use fallback questions - take first 5
                    appState.assignmentClassificationQuestions = fallbackAssignmentClassificationQuestions.slice(0, 5);
                    showNotification('Using default questions due to AI response format issue', 'error');
                }
                
                // Initialize answers array
                appState.assignmentClassificationAnswers = new Array(appState.assignmentClassificationQuestions.length).fill('');
                appState.currentAssignmentClassificationQuestionIndex = 0;
                
                // Show the assignment classification questions section
                showSection('assignmentClassificationQuestions');
                renderCurrentAssignmentClassificationQuestion();
            } catch (error) {
                showNotification(`Error generating assignment classification questions: ${error.message}`, 'error');
                elements.generateAssignmentClassificationQuestionsBtn.disabled = false;
                elements.generateAssignmentClassificationQuestionsBtn.textContent = 'Next';
                showSection('assignmentTopic');
            }
        }

        // Render Current Assignment Classification Question
        function renderCurrentAssignmentClassificationQuestion() {
            const progress = ((appState.currentAssignmentClassificationQuestionIndex + 1) / appState.assignmentClassificationQuestions.length) * 100;
            elements.assignmentClassificationProgressFill.style.width = `${progress}%`;
            
            const currentQuestion = appState.assignmentClassificationQuestions[appState.currentAssignmentClassificationQuestionIndex];
            const selectedOption = appState.assignmentClassificationAnswers[appState.currentAssignmentClassificationQuestionIndex];
            
            elements.assignmentClassificationQuestionsContainer.innerHTML = `
                <div class="question-container">
                    <h3>Classification Question ${appState.currentAssignmentClassificationQuestionIndex + 1} of ${appState.assignmentClassificationQuestions.length}</h3>
                    <p>${currentQuestion.question}</p>
                    <div class="option-container">
                        ${currentQuestion.options.map((option, index) => `
                            <label class="option ${selectedOption === option ? 'selected' : ''}">
                                <input type="radio" name="assignment-classification-question-${appState.currentAssignmentClassificationQuestionIndex}" value="${option}" ${selectedOption === option ? 'checked' : ''}>
                                ${option}
                            </label>
                        `).join('')}
                    </div>
                    <div style="margin-top: 15px;">
                        ${appState.currentAssignmentClassificationQuestionIndex > 0 ? '<button id="prev-assignment-classification-question-btn">Previous</button>' : ''}
                        ${appState.currentAssignmentClassificationQuestionIndex < appState.assignmentClassificationQuestions.length - 1 ? '<button id="next-assignment-classification-question-btn">Next</button>' : '<button id="finish-assignment-classification-btn">Continue to Assignment Options</button>'}
                    </div>
                </div>
            `;
            
            // Add event listeners for options
            const optionElements = document.querySelectorAll('.option');
            optionElements.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    optionElements.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the answer
                    const input = option.querySelector('input');
                    input.checked = true;
                    // Store the answer
                    appState.assignmentClassificationAnswers[appState.currentAssignmentClassificationQuestionIndex] = input.value;
                });
            });
            
            if (appState.currentAssignmentClassificationQuestionIndex > 0) {
                document.getElementById('prev-assignment-classification-question-btn').addEventListener('click', previousAssignmentClassificationQuestion);
            }
            
            if (appState.currentAssignmentClassificationQuestionIndex < appState.assignmentClassificationQuestions.length - 1) {
                document.getElementById('next-assignment-classification-question-btn').addEventListener('click', nextAssignmentClassificationQuestion);
            } else {
                document.getElementById('finish-assignment-classification-btn').addEventListener('click', finishAssignmentClassificationQuestions);
            }
        }

        // Assignment Classification Question Navigation
        function nextAssignmentClassificationQuestion() {
            appState.currentAssignmentClassificationQuestionIndex++;
            renderCurrentAssignmentClassificationQuestion();
        }

        function previousAssignmentClassificationQuestion() {
            appState.currentAssignmentClassificationQuestionIndex--;
            renderCurrentAssignmentClassificationQuestion();
        }

        function finishAssignmentClassificationQuestions() {
            // Check if all questions have answers
            const allAnswered = appState.assignmentClassificationAnswers.every(answer => answer.trim() !== '');
            if (!allAnswered) {
                showNotification('Please answer all classification questions before proceeding', 'error');
                return;
            }
            
            // Now proceed to the assignment customization questions
            generateAssignmentQuestions();
        }

        // Assignment Questions Generation
        function generateAssignmentQuestions() {
            elements.generateAssignmentClassificationQuestionsBtn.disabled = true;
            elements.generateAssignmentClassificationQuestionsBtn.textContent = 'Preparing questions...';
            
            // Set predefined questions for the assignment
            appState.assignmentQuestions = [
                {
                    question: "What grade level is this assignment for?",
                    options: ["Elementary (K-5)", "Middle School (6-8)", "High School (9-12)", "College/University"],
                    variable: "assignmentGradeLevel"
                },
                {
                    question: "What type of assignment do you want to create?",
                    options: ["Essay/Research Paper", "Problem Set", "Project-based", "Quiz/Test", "Presentation", "Lab Report"],
                    variable: "assignmentType"
                },
                {
                    question: "How long should the assignment be?",
                    options: ["Short (1-2 pages)", "Medium (3-5 pages)", "Long (6+ pages)"],
                    variable: "assignmentLength"
                },
                {
                    question: "What difficulty level is appropriate?",
                    options: ["Beginner", "Intermediate", "Advanced", "Mixed Levels"],
                    variable: "assignmentDifficulty"
                },
                {
                    question: "What resources should be included?",
                    options: ["None", "Reading list", "Research guidelines", "Templates", "All of the above"],
                    variable: "assignmentResources"
                },
                {
                    question: "What submission format do you prefer?",
                    options: ["Written document", "Digital submission", "Presentation", "Physical project", "Online quiz"],
                    variable: "assignmentSubmission"
                },
                {
                    question: "What font style do you prefer?",
                    options: ["Normal", "Handwritten", "Typewriter", "Other"],
                    variable: "assignmentFont"
                }
            ];
            
            // Initialize answers array for these questions
            appState.assignmentAnswers = new Array(appState.assignmentQuestions.length).fill('');
            appState.currentAssignmentQuestionIndex = 0;
            
            // Show the assignment questions section
            showSection('assignmentQuestions');
            renderCurrentAssignmentQuestion();
        }

        // Render Current Assignment Question
        function renderCurrentAssignmentQuestion() {
            const progress = ((appState.currentAssignmentQuestionIndex + 1) / appState.assignmentQuestions.length) * 100;
            elements.assignmentProgressFill.style.width = `${progress}%`;
            
            const currentQuestion = appState.assignmentQuestions[appState.currentAssignmentQuestionIndex];
            const selectedOption = appState.assignmentAnswers[appState.currentAssignmentQuestionIndex];
            
            elements.assignmentQuestionsContainer.innerHTML = `
                <div class="question-container">
                    <h3>Question ${appState.currentAssignmentQuestionIndex + 1} of ${appState.assignmentQuestions.length}</h3>
                    <p>${currentQuestion.question}</p>
                    <div class="option-container">
                        ${currentQuestion.options.map((option, index) => `
                            <label class="option ${selectedOption === option ? 'selected' : ''}">
                                <input type="radio" name="assignment-question-${appState.currentAssignmentQuestionIndex}" value="${option}" ${selectedOption === option ? 'checked' : ''}>
                                ${option}
                            </label>
                        `).join('')}
                    </div>
                    <div style="margin-top: 15px;">
                        ${appState.currentAssignmentQuestionIndex > 0 ? '<button id="prev-assignment-question-btn">Previous</button>' : ''}
                        ${appState.currentAssignmentQuestionIndex < appState.assignmentQuestions.length - 1 ? '<button id="next-assignment-question-btn">Next</button>' : '<button id="finish-assignment-questions-btn">Finish</button>'}
                    </div>
                </div>
            `;
            
            // Show font list if font question and "Other" option is selected
            if (currentQuestion.variable === "assignmentFont" && selectedOption === "Other") {
                elements.assignmentFontListContainer.classList.add('show');
                renderAssignmentFontList();
            } else {
                elements.assignmentFontListContainer.classList.remove('show');
            }
            
            // Add event listeners for options
            const optionElements = document.querySelectorAll('.option');
            optionElements.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    optionElements.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the answer
                    const input = option.querySelector('input');
                    input.checked = true;
                    // Store the answer in appState using the variable name
                    const variableName = appState.assignmentQuestions[appState.currentAssignmentQuestionIndex].variable;
                    appState[variableName] = input.value;
                    // Also update the answers array for progress tracking
                    appState.assignmentAnswers[appState.currentAssignmentQuestionIndex] = input.value;
                    
                    // Show/hide font list based on selection
                    if (variableName === "assignmentFont" && input.value === "Other") {
                        elements.assignmentFontListContainer.classList.add('show');
                        renderAssignmentFontList();
                    } else {
                        elements.assignmentFontListContainer.classList.remove('show');
                    }
                });
            });
            
            if (appState.currentAssignmentQuestionIndex > 0) {
                document.getElementById('prev-assignment-question-btn').addEventListener('click', previousAssignmentQuestion);
            }
            
            if (appState.currentAssignmentQuestionIndex < appState.assignmentQuestions.length - 1) {
                document.getElementById('next-assignment-question-btn').addEventListener('click', nextAssignmentQuestion);
            } else {
                document.getElementById('finish-assignment-questions-btn').addEventListener('click', finishAssignmentQuestions);
            }
        }

        // Render Assignment Font List
        function renderAssignmentFontList() {
            elements.assignmentFontListContainer.innerHTML = fonts.map(font => `
                <div class="font-option ${appState.selectedAssignmentFont === font ? 'selected' : ''}" data-font="${font}">
                    ${font}
                </div>
            `).join('');
            
            // Add event listeners to font options
            const fontOptions = document.querySelectorAll('.font-option');
            fontOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    fontOptions.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the selected font
                    appState.selectedAssignmentFont = option.dataset.font;
                });
            });
        }

        // Assignment Question Navigation
        function nextAssignmentQuestion() {
            appState.currentAssignmentQuestionIndex++;
            renderCurrentAssignmentQuestion();
        }

        function previousAssignmentQuestion() {
            appState.currentAssignmentQuestionIndex--;
            renderCurrentAssignmentQuestion();
        }

        function finishAssignmentQuestions() {
            // Check if all questions have answers
            const allAnswered = appState.assignmentAnswers.every(answer => answer.trim() !== '');
            if (!allAnswered) {
                showNotification('Please answer all questions before proceeding', 'error');
                return;
            }
            
            // Check if font is "Other" and no specific font is selected
            if (appState.assignmentFont === "Other" && !appState.selectedAssignmentFont) {
                showNotification('Please select a specific font', 'error');
                return;
            }
            
            elements.generateAssignmentBtn.disabled = false;
            showNotification('All questions answered. You can now generate your assignment!');
        }

        // Assignment Generation
        async function generateAssignment() {
            elements.generateAssignmentBtn.disabled = true;
            elements.generateAssignmentBtn.textContent = 'Generating assignment...';
            
            // Show generating animation
            showSection('generatingAssignment');
            
            try {
                // Extract the parameters from appState
                const { 
                    assignmentTopic, 
                    assignmentGradeLevel, 
                    assignmentType, 
                    assignmentLength, 
                    assignmentDifficulty, 
                    assignmentResources, 
                    assignmentSubmission,
                    assignmentFont,
                    selectedAssignmentFont,
                    assignmentClassificationQuestions,
                    assignmentClassificationAnswers
                } = appState;
                
                // Determine the actual font to use
                let actualFont = assignmentFont;
                if (assignmentFont === "Other") {
                    actualFont = selectedAssignmentFont || "Arial";
                }
                
                // Build classification information string
                let classificationInfo = '';
                for (let i = 0; i < assignmentClassificationQuestions.length; i++) {
                    classificationInfo += `Q: ${assignmentClassificationQuestions[i].question}\nA: ${assignmentClassificationAnswers[i]}\n\n`;
                }
                
                // Build the prompt
                const prompt = `Create a complete HTML, CSS, and JavaScript file for an assignment about "${assignmentTopic}". 

The user has provided the following additional classification information:
 ${classificationInfo}

The assignment should have the following features:

1. Grade Level: ${assignmentGradeLevel}
2. Assignment Type: ${assignmentType}
3. Length: ${assignmentLength}
4. Difficulty Level: ${assignmentDifficulty}
5. Resources: ${assignmentResources}
6. Submission Format: ${assignmentSubmission}
7. Font Style: ${actualFont}

The assignment should be well-structured with appropriate headings, instructions, questions, and possibly rubrics. Use the classification information to tailor the content to the user's specific needs and requirements.

Additionally, include a download button at the top of the page with the id 'download-pdf-btn'. This button should trigger the download of the page as a PDF. Use the following JavaScript for the button:

\`\`\`javascript
document.getElementById('download-pdf-btn').addEventListener('click', function() {
    window.print();
});
\`\`\`

Also, add the following CSS to hide the button when printing:

\`\`\`css
@media print {
    #download-pdf-btn {
        display: none;
    }
}
\`\`\`

The assignment should be responsive and look good when printed on A4 paper.

Include a watermark at the bottom of each page that says "Developed under HOPE Research Team | by Justin".

Return only the complete HTML code without any additional explanations.`;
                
                const assignmentHTML = await callGeminiAPI(prompt);
                appState.generatedAssignment = assignmentHTML;
                
                // Save to history
                saveToHistory(appState.assignmentTopic, assignmentHTML, 'assignment');
                
                // Show preview section
                showSection('assignmentPreview');
            } catch (error) {
                showNotification(`Error generating assignment: ${error.message}`, 'error');
                elements.generateAssignmentBtn.disabled = false;
                elements.generateAssignmentBtn.textContent = 'Generate Assignment';
                showSection('assignmentQuestions');
            }
        }

        // Assignment Preview and Download
        function previewAssignment() {
            const newWindow = window.open();
            newWindow.document.write(appState.generatedAssignment);
            newWindow.document.close();
        }

        function downloadAssignmentAsPDF() {
            const newWindow = window.open();
            newWindow.document.write(appState.generatedAssignment);
            newWindow.document.close();
            
            // Wait for the content to load, then trigger print
            setTimeout(() => {
                newWindow.print();
            }, 1000);
        }

        // Reset for New Assignment
        function resetForNewAssignment() {
            appState.assignmentTopic = '';
            appState.assignmentGradeLevel = '';
            appState.assignmentType = '';
            appState.assignmentLength = '';
            appState.assignmentDifficulty = '';
            appState.assignmentResources = '';
            appState.assignmentSubmission = '';
            appState.assignmentFont = '';
            appState.selectedAssignmentFont = '';
            appState.assignmentQuestions = [];
            appState.assignmentAnswers = [];
            appState.currentAssignmentQuestionIndex = 0;
            appState.assignmentClassificationQuestions = [];
            appState.assignmentClassificationAnswers = [];
            appState.currentAssignmentClassificationQuestionIndex = 0;
            elements.assignmentTopicInput.value = '';
            showSection('assignmentTopic');
        }

        // Project Classification Questions Generation
        async function generateProjectClassificationQuestions() {
            const topic = elements.projectTopicInput.value.trim();
            const level = elements.projectLevelSelect.value;
            
            if (!topic) {
                showNotification('Please enter a project topic', 'error');
                return;
            }
            
            if (!level) {
                showNotification('Please select a project level', 'error');
                return;
            }

            appState.projectTopic = topic;
            appState.projectLevel = level;
            elements.generateProjectClassificationQuestionsBtn.disabled = true;
            elements.generateProjectClassificationQuestionsBtn.textContent = 'Generating questions...';
            
            // Show generating animation
            showSection('generatingProjectClassification');
            
            try {
                // Build the prompt to generate project classification questions with strict formatting instructions
                const prompt = `Based on the topic "${topic}" for a ${level} project, generate 3-5 specific classification questions that would help gather more information about what kind of project the user wants. These questions should help narrow down the focus, scope, and specific aspects of the project.

For each question, provide 3-4 multiple choice options.

IMPORTANT: You must return the response in valid JSON format exactly as shown below, with no additional text, explanations, or markdown formatting:

{
  "questions": [
    {
      "question": "Question text here",
      "options": ["Option 1", "Option 2", "Option 3", "Option 4"]
    },
    {
      "question": "Another question here",
      "options": ["Option A", "Option B", "Option C"]
    }
  ]
}

Do not include any text before or after the JSON. The response must be pure JSON that can be parsed by JSON.parse().`;
                
                const response = await callGeminiAPI(prompt);
                
                // Try to parse the JSON response
                let data;
                try {
                    // Clean the response - remove any markdown code blocks or extra text
                    let cleanResponse = response.trim();
                    if (cleanResponse.startsWith('```json')) {
                        cleanResponse = cleanResponse.replace(/```json\n?/, '').replace(/\n?```$/, '');
                    } else if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/```\n?/, '').replace(/\n?```$/, '');
                    }
                    
                    // Try to find JSON object in the response
                    const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        cleanResponse = jsonMatch[0];
                    }
                    
                    data = JSON.parse(cleanResponse);
                    
                    // Validate the structure
                    if (!data.questions || !Array.isArray(data.questions)) {
                        throw new Error('Invalid JSON structure');
                    }
                    
                    // Validate each question
                    data.questions = data.questions.filter(q => 
                        q.question && q.options && Array.isArray(q.options) && q.options.length >= 2
                    );
                    
                    if (data.questions.length === 0) {
                        throw new Error('No valid questions found');
                    }
                    
                    // Limit to 5 questions
                    if (data.questions.length > 5) {
                        data.questions = data.questions.slice(0, 5);
                    }
                    
                    appState.projectClassificationQuestions = data.questions;
                } catch (parseError) {
                    console.error('Failed to parse AI response:', parseError);
                    console.log('Using fallback questions');
                    
                    // Use fallback questions - take first 5
                    appState.projectClassificationQuestions = fallbackProjectClassificationQuestions.slice(0, 5);
                    showNotification('Using default questions due to AI response format issue', 'error');
                }
                
                // Initialize answers array
                appState.projectClassificationAnswers = new Array(appState.projectClassificationQuestions.length).fill('');
                appState.currentProjectClassificationQuestionIndex = 0;
                
                // Show the project classification questions section
                showSection('projectClassificationQuestions');
                renderCurrentProjectClassificationQuestion();
            } catch (error) {
                showNotification(`Error generating project classification questions: ${error.message}`, 'error');
                elements.generateProjectClassificationQuestionsBtn.disabled = false;
                elements.generateProjectClassificationQuestionsBtn.textContent = 'Next';
                showSection('projectTopic');
            }
        }

        // Render Current Project Classification Question
        function renderCurrentProjectClassificationQuestion() {
            const progress = ((appState.currentProjectClassificationQuestionIndex + 1) / appState.projectClassificationQuestions.length) * 100;
            elements.projectClassificationProgressFill.style.width = `${progress}%`;
            
            const currentQuestion = appState.projectClassificationQuestions[appState.currentProjectClassificationQuestionIndex];
            const selectedOption = appState.projectClassificationAnswers[appState.currentProjectClassificationQuestionIndex];
            
            elements.projectClassificationQuestionsContainer.innerHTML = `
                <div class="question-container">
                    <h3>Classification Question ${appState.currentProjectClassificationQuestionIndex + 1} of ${appState.projectClassificationQuestions.length}</h3>
                    <p>${currentQuestion.question}</p>
                    <div class="option-container">
                        ${currentQuestion.options.map((option, index) => `
                            <label class="option ${selectedOption === option ? 'selected' : ''}">
                                <input type="radio" name="project-classification-question-${appState.currentProjectClassificationQuestionIndex}" value="${option}" ${selectedOption === option ? 'checked' : ''}>
                                ${option}
                            </label>
                        `).join('')}
                    </div>
                    <div style="margin-top: 15px;">
                        ${appState.currentProjectClassificationQuestionIndex > 0 ? '<button id="prev-project-classification-question-btn">Previous</button>' : ''}
                        ${appState.currentProjectClassificationQuestionIndex < appState.projectClassificationQuestions.length - 1 ? '<button id="next-project-classification-question-btn">Next</button>' : '<button id="finish-project-classification-btn">Continue to Project Options</button>'}
                    </div>
                </div>
            `;
            
            // Add event listeners for options
            const optionElements = document.querySelectorAll('.option');
            optionElements.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    optionElements.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the answer
                    const input = option.querySelector('input');
                    input.checked = true;
                    // Store the answer
                    appState.projectClassificationAnswers[appState.currentProjectClassificationQuestionIndex] = input.value;
                });
            });
            
            if (appState.currentProjectClassificationQuestionIndex > 0) {
                document.getElementById('prev-project-classification-question-btn').addEventListener('click', previousProjectClassificationQuestion);
            }
            
            if (appState.currentProjectClassificationQuestionIndex < appState.projectClassificationQuestions.length - 1) {
                document.getElementById('next-project-classification-question-btn').addEventListener('click', nextProjectClassificationQuestion);
            } else {
                document.getElementById('finish-project-classification-btn').addEventListener('click', finishProjectClassificationQuestions);
            }
        }

        // Project Classification Question Navigation
        function nextProjectClassificationQuestion() {
            appState.currentProjectClassificationQuestionIndex++;
            renderCurrentProjectClassificationQuestion();
        }

        function previousProjectClassificationQuestion() {
            appState.currentProjectClassificationQuestionIndex--;
            renderCurrentProjectClassificationQuestion();
        }

        function finishProjectClassificationQuestions() {
            // Check if all questions have answers
            const allAnswered = appState.projectClassificationAnswers.every(answer => answer.trim() !== '');
            if (!allAnswered) {
                showNotification('Please answer all classification questions before proceeding', 'error');
                return;
            }
            
            // Now proceed to the project customization questions
            generateProjectQuestions();
        }

        // Project Questions Generation
        function generateProjectQuestions() {
            elements.generateProjectClassificationQuestionsBtn.disabled = true;
            elements.generateProjectClassificationQuestionsBtn.textContent = 'Preparing questions...';
            
            // Set predefined questions for the project
            appState.projectQuestions = [
                {
                    question: "What type of project do you want to create?",
                    options: ["Web Application", "Mobile App", "Desktop Software", "Data Analysis System", "Machine Learning Model", "IoT Solution"],
                    variable: "projectType"
                },
                {
                    question: "What programming languages do you prefer? (Select multiple)",
                    options: programmingLanguages,
                    variable: "projectLanguages",
                    isMultiSelect: true
                },
                {
                    question: "What framework or technology stack do you prefer?",
                    options: ["React", "Angular", "Vue.js", "Django", "Flask", "Spring Boot", "ASP.NET", "Laravel", "Express.js", "No framework"],
                    variable: "projectFramework"
                },
                {
                    question: "What database do you want to use?",
                    options: ["MySQL", "PostgreSQL", "MongoDB", "SQLite", "Firebase", "Oracle", "SQL Server", "No database needed"],
                    variable: "projectDatabase"
                },
                {
                    question: "What UI/UX design approach do you prefer?",
                    options: ["Modern minimalist", "Colorful and vibrant", "Corporate professional", "Dark theme", "Custom design"],
                    variable: "projectUI"
                },
                {
                    question: "What level of documentation do you need?",
                    options: ["Basic comments in code", "Detailed documentation", "Complete with user manual", "Academic level documentation"],
                    variable: "projectDocumentation"
                },
                {
                    question: "How do you want to deploy the project?",
                    options: ["Local deployment only", "Cloud deployment (AWS/Azure/GCP)", "Docker container", "Traditional server", "No deployment needed"],
                    variable: "projectDeployment"
                },
                {
                    question: "Do you want to include the current date and time in the project?",
                    options: ["Yes, include current date and time", "No, don't include date and time"],
                    variable: "includeCurrentDate"
                },
                {
                    question: "What font style do you prefer for documentation?",
                    options: ["Normal", "Handwritten", "Typewriter", "Other"],
                    variable: "projectFont"
                }
            ];
            
            // Initialize answers array for these questions
            appState.projectAnswers = new Array(appState.projectQuestions.length).fill('');
            appState.currentProjectQuestionIndex = 0;
            
            // Show the project questions section
            showSection('projectQuestions');
            renderCurrentProjectQuestion();
        }

        // Render Current Project Question
        function renderCurrentProjectQuestion() {
            const progress = ((appState.currentProjectQuestionIndex + 1) / appState.projectQuestions.length) * 100;
            elements.projectProgressFill.style.width = `${progress}%`;
            
            const currentQuestion = appState.projectQuestions[appState.currentProjectQuestionIndex];
            const selectedOption = appState.projectAnswers[appState.currentProjectQuestionIndex];
            
            if (currentQuestion.isMultiSelect) {
                // Multi-select question rendering
                elements.projectQuestionsContainer.innerHTML = `
                    <div class="question-container">
                        <h3>Question ${appState.currentProjectQuestionIndex + 1} of ${appState.projectQuestions.length}</h3>
                        <p>${currentQuestion.question}</p>
                        <div class="multi-select-container show">
                            <div class="multi-select-options">
                                ${currentQuestion.options.map((option, index) => `
                                    <div class="multi-select-option">
                                        <input type="checkbox" id="lang-${index}" value="${option}" ${selectedOption && selectedOption.includes(option) ? 'checked' : ''}>
                                        <label for="lang-${index}">${option}</label>
                                    </div>
                                `).join('')}
                            </div>
                            <div class="selected-items" id="selected-languages">
                                ${selectedOption ? selectedOption.map(lang => `<span class="selected-item">${lang}</span>`).join('') : 'No languages selected'}
                            </div>
                        </div>
                        <div style="margin-top: 15px;">
                            ${appState.currentProjectQuestionIndex > 0 ? '<button id="prev-project-question-btn">Previous</button>' : ''}
                            ${appState.currentProjectQuestionIndex < appState.projectQuestions.length - 1 ? '<button id="next-project-question-btn">Next</button>' : '<button id="finish-project-questions-btn">Finish</button>'}
                        </div>
                    </div>
                `;
                
                // Add event listeners for checkboxes
                const checkboxes = document.querySelectorAll('.multi-select-option input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', () => {
                        const checkedOptions = Array.from(checkboxes)
                            .filter(cb => cb.checked)
                            .map(cb => cb.value);
                        appState.projectAnswers[appState.currentProjectQuestionIndex] = checkedOptions;
                        
                        // Update selected items display
                        const selectedItemsDiv = document.getElementById('selected-languages');
                        if (checkedOptions.length > 0) {
                            selectedItemsDiv.innerHTML = checkedOptions.map(lang => `<span class="selected-item">${lang}</span>`).join('');
                        } else {
                            selectedItemsDiv.innerHTML = 'No languages selected';
                        }
                    });
                });
            } else {
                // Regular single-select question rendering
                elements.projectQuestionsContainer.innerHTML = `
                    <div class="question-container">
                        <h3>Question ${appState.currentProjectQuestionIndex + 1} of ${appState.projectQuestions.length}</h3>
                        <p>${currentQuestion.question}</p>
                        <div class="option-container">
                            ${currentQuestion.options.map((option, index) => `
                                <label class="option ${selectedOption === option ? 'selected' : ''}">
                                    <input type="radio" name="project-question-${appState.currentProjectQuestionIndex}" value="${option}" ${selectedOption === option ? 'checked' : ''}>
                                    ${option}
                                </label>
                            `).join('')}
                        </div>
                        <div style="margin-top: 15px;">
                            ${appState.currentProjectQuestionIndex > 0 ? '<button id="prev-project-question-btn">Previous</button>' : ''}
                            ${appState.currentProjectQuestionIndex < appState.projectQuestions.length - 1 ? '<button id="next-project-question-btn">Next</button>' : '<button id="finish-project-questions-btn">Finish</button>'}
                        </div>
                    </div>
                `;
                
                // Add event listeners for options
                const optionElements = document.querySelectorAll('.option');
                optionElements.forEach(option => {
                    option.addEventListener('click', () => {
                        // Remove selected class from all options
                        optionElements.forEach(opt => opt.classList.remove('selected'));
                        // Add selected class to clicked option
                        option.classList.add('selected');
                        // Update the answer
                        const input = option.querySelector('input');
                        input.checked = true;
                        // Store the answer in appState using the variable name
                        const variableName = appState.projectQuestions[appState.currentProjectQuestionIndex].variable;
                        appState[variableName] = input.value;
                        // Also update the answers array for progress tracking
                        appState.projectAnswers[appState.currentProjectQuestionIndex] = input.value;
                        
                        // Show/hide font list based on selection
                        if (variableName === "projectFont" && input.value === "Other") {
                            elements.projectFontListContainer.classList.add('show');
                            renderProjectFontList();
                        } else {
                            elements.projectFontListContainer.classList.remove('show');
                        }
                        
                        // Handle includeCurrentDate option
                        if (variableName === "includeCurrentDate") {
                            appState.includeCurrentDate = input.value === "Yes, include current date and time";
                            if (appState.includeCurrentDate) {
                                // Get current date and time
                                const now = new Date();
                                appState.currentDateTime = now.toLocaleString();
                            }
                        }
                    });
                });
            }
            
            if (appState.currentProjectQuestionIndex > 0) {
                document.getElementById('prev-project-question-btn').addEventListener('click', previousProjectQuestion);
            }
            
            if (appState.currentProjectQuestionIndex < appState.projectQuestions.length - 1) {
                document.getElementById('next-project-question-btn').addEventListener('click', nextProjectQuestion);
            } else {
                document.getElementById('finish-project-questions-btn').addEventListener('click', finishProjectQuestions);
            }
        }

        // Render Project Font List
        function renderProjectFontList() {
            elements.projectFontListContainer.innerHTML = fonts.map(font => `
                <div class="font-option ${appState.selectedProjectFont === font ? 'selected' : ''}" data-font="${font}">
                    ${font}
                </div>
            `).join('');
            
            // Add event listeners to font options
            const fontOptions = document.querySelectorAll('.font-option');
            fontOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    fontOptions.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the selected font
                    appState.selectedProjectFont = option.dataset.font;
                });
            });
        }

        // Project Question Navigation
        function nextProjectQuestion() {
            appState.currentProjectQuestionIndex++;
            renderCurrentProjectQuestion();
        }

        function previousProjectQuestion() {
            appState.currentProjectQuestionIndex--;
            renderCurrentProjectQuestion();
        }

        function finishProjectQuestions() {
            // Check if all questions have answers
            const allAnswered = appState.projectAnswers.every(answer => {
                if (Array.isArray(answer)) {
                    return answer.length > 0;
                }
                return answer && answer.trim() !== '';
            });
            
            if (!allAnswered) {
                showNotification('Please answer all questions before proceeding', 'error');
                return;
            }
            
            // Check if font is "Other" and no specific font is selected
            if (appState.projectFont === "Other" && !appState.selectedProjectFont) {
                showNotification('Please select a specific font', 'error');
                return;
            }
            
            elements.generateProjectBtn.disabled = false;
            showNotification('All questions answered. You can now generate your complete project!');
        }

        // Project Generation
        async function generateProject() {
            elements.generateProjectBtn.disabled = true;
            elements.generateProjectBtn.textContent = 'Generating project...';
            
            // Show generating animation
            showSection('generatingProject');
            
            try {
                // Extract the parameters from appState
                const { 
                    projectTopic, 
                    projectLevel,
                    projectType, 
                    projectLanguages,
                    projectFramework, 
                    projectDatabase, 
                    projectUI, 
                    projectDocumentation, 
                    projectDeployment,
                    projectFont,
                    selectedProjectFont,
                    projectClassificationQuestions,
                    projectClassificationAnswers,
                    includeCurrentDate,
                    currentDateTime
                } = appState;
                
                // Determine the actual font to use
                let actualFont = projectFont;
                if (projectFont === "Other") {
                    actualFont = selectedProjectFont || "Arial";
                }
                
                // Build classification information string
                let classificationInfo = '';
                for (let i = 0; i < projectClassificationQuestions.length; i++) {
                    classificationInfo += `Q: ${projectClassificationQuestions[i].question}\nA: ${projectClassificationAnswers[i]}\n\n`;
                }
                
                // Add date information if requested
                let dateInfo = '';
                if (includeCurrentDate && currentDateTime) {
                    dateInfo = `The current date and time is: ${currentDateTime}. Please include this information in the project documentation where appropriate.`;
                }
                
                // Initialize project files object
                appState.generatedProject = {
                    documentation: '',
                    sourceCode: {},
                    requirements: '',
                    workflow: '',
                    readme: ''
                };
                
                // Generate project documentation
                const documentationPrompt = `Create comprehensive documentation for a ${projectLevel} ${projectType} project about "${projectTopic}". 

The user has provided the following additional classification information:
 ${classificationInfo}

 ${dateInfo}

The project specifications are:
- Level: ${projectLevel}
- Type: ${projectType}
- Languages: ${Array.isArray(projectLanguages) ? projectLanguages.join(', ') : projectLanguages}
- Framework: ${projectFramework}
- Database: ${projectDatabase}
- UI/UX: ${projectUI}
- Documentation Level: ${projectDocumentation}
- Deployment: ${projectDeployment}

Create a detailed project documentation in HTML format with the following sections:
1. Project Overview
2. Features
3. System Architecture
4. Technology Stack
5. Installation Guide
6. User Guide
7. API Documentation (if applicable)
8. Testing Guide
9. Deployment Guide
10. Future Enhancements

Use professional styling with ${actualFont} font. Include SVG illustrations for the system architecture and workflow diagrams.

Return only the complete HTML code without any additional explanations.`;
                
                appState.generatedProject.documentation = await callGeminiAPI(documentationPrompt);
                
                // Generate project requirements
                const requirementsPrompt = `Create a detailed requirements document for a ${projectLevel} ${projectType} project about "${projectTopic}". 

The user has provided the following additional classification information:
 ${classificationInfo}

 ${dateInfo}

The project specifications are:
- Level: ${projectLevel}
- Type: ${projectType}
- Languages: ${Array.isArray(projectLanguages) ? projectLanguages.join(', ') : projectLanguages}
- Framework: ${projectFramework}
- Database: ${projectDatabase}
- UI/UX: ${projectUI}
- Documentation Level: ${projectDocumentation}
- Deployment: ${projectDeployment}

Create a requirements document in HTML format with the following sections:
1. Functional Requirements
2. Non-Functional Requirements
3. User Requirements
4. System Requirements
5. Technical Specifications
6. Constraints and Assumptions

Use professional styling with ${actualFont} font.

Return only the complete HTML code without any additional explanations.`;
                
                appState.generatedProject.requirements = await callGeminiAPI(requirementsPrompt);
                
                // Generate README file
                const readmePrompt = `Create a comprehensive README.md file for a ${projectLevel} ${projectType} project about "${projectTopic}". 

The user has provided the following additional classification information:
 ${classificationInfo}

 ${dateInfo}

The project specifications are:
- Level: ${projectLevel}
- Type: ${projectType}
- Languages: ${Array.isArray(projectLanguages) ? projectLanguages.join(', ') : projectLanguages}
- Framework: ${projectFramework}
- Database: ${projectDatabase}
- UI/UX: ${projectUI}
- Documentation Level: ${projectDocumentation}
- Deployment: ${projectDeployment}

Create a README.md file with the following sections:
1. Project Title and Description
2. Features
3. Installation Instructions
4. Usage Guide
5. Configuration
6. Contributing Guidelines
7. License Information
8. Contact Information

Use proper Markdown formatting.

Return only the complete README.md content without any additional explanations.`;
                
                appState.generatedProject.readme = await callGeminiAPI(readmePrompt);
                
                // Generate source code files based on project type
                await generateSourceCode();
                
                // Generate workflow SVG
                const workflowPrompt = `Create an SVG workflow diagram for a ${projectLevel} ${projectType} project about "${projectTopic}". 

The user has provided the following additional classification information:
 ${classificationInfo}

 ${dateInfo}

The project specifications are:
- Level: ${projectLevel}
- Type: ${projectType}
- Languages: ${Array.isArray(projectLanguages) ? projectLanguages.join(', ') : projectLanguages}
- Framework: ${projectFramework}
- Database: ${projectDatabase}
- UI/UX: ${projectUI}
- Documentation Level: ${projectDocumentation}
- Deployment: ${projectDeployment}

Create a professional workflow diagram showing the complete project flow from user interaction to data processing and storage. Use modern design with appropriate colors and shapes.

Return only the complete SVG code without any additional explanations.`;
                
                appState.generatedProject.workflow = await callGeminiAPI(workflowPrompt);
                
                // Prepare file list for display
                prepareProjectFileList();
                
                // Save to history
                saveToHistory(appState.projectTopic, appState.generatedProject, 'project');
                
                // Show preview section
                showSection('projectPreview');
            } catch (error) {
                showNotification(`Error generating project: ${error.message}`, 'error');
                elements.generateProjectBtn.disabled = false;
                elements.generateProjectBtn.textContent = 'Generate Project';
                showSection('projectQuestions');
            }
        }

        // Generate Source Code based on project type
        async function generateSourceCode() {
            const { projectLevel, projectType, projectTopic, projectLanguages, projectFramework, projectDatabase, includeCurrentDate, currentDateTime } = appState;
            
            try {
                // Generate main application file
                let dateInfo = '';
                if (includeCurrentDate && currentDateTime) {
                    dateInfo = `The current date and time is: ${currentDateTime}. Please include this information in the code comments where appropriate.`;
                }
                
                const mainFilePrompt = `Create the main application file for a ${projectLevel} ${projectType} project about "${projectTopic}" using ${Array.isArray(projectLanguages) ? projectLanguages.join(', ') : projectLanguages} and ${projectFramework}. 

 ${dateInfo}

The project should:
1. Be fully functional with proper error handling
2. Include comments explaining the code
3. Follow best practices for the selected languages
4. Connect to ${projectDatabase} if applicable
5. Implement core features related to "${projectTopic}"
6. Include proper structure suitable for a ${projectLevel} project

Return only the complete source code without any additional explanations.`;
                
                let mainFileExtension = getFileExtension(Array.isArray(projectLanguages) ? projectLanguages[0] : projectLanguages);
                let mainFileName = `index.${mainFileExtension}`;
                
                if (projectType === "Web Application") {
                    mainFileName = `index.html`;
                    appState.generatedProject.sourceCode[mainFileName] = await callGeminiAPI(mainFilePrompt);
                    
                    // Generate CSS file
                    const cssPrompt = `Create a CSS file for a ${projectLevel} ${projectType} about "${projectTopic}" with modern styling, responsive design, and animations. Use the ${appState.projectUI} design approach.

 ${dateInfo}

Return only the complete CSS code without any additional explanations.`;
                    appState.generatedProject.sourceCode["styles.css"] = await callGeminiAPI(cssPrompt);
                    
                    // Generate JavaScript file
                    const jsPrompt = `Create a JavaScript file for a ${projectLevel} ${projectType} about "${projectTopic}" with modern ES6+ syntax, proper error handling, and interactive features.

 ${dateInfo}

Return only the complete JavaScript code without any additional explanations.`;
                    appState.generatedProject.sourceCode["script.js"] = await callGeminiAPI(jsPrompt);
                } else {
                    appState.generatedProject.sourceCode[mainFileName] = await callGeminiAPI(mainFilePrompt);
                }
                
                // Generate additional files based on project type
                if (projectType === "Web Application" || projectType === "Mobile App") {
                    // Generate package.json for Node.js projects
                    if (projectLanguages.includes("JavaScript/TypeScript") || projectFramework === "React" || projectFramework === "Angular" || projectFramework === "Vue.js" || projectFramework === "Express.js") {
                        const packageJsonPrompt = `Create a package.json file for a ${projectLevel} ${projectType} about "${projectTopic}" using ${projectFramework}. Include appropriate dependencies, scripts, and project metadata.

 ${dateInfo}

Return only the complete package.json content without any additional explanations.`;
                        appState.generatedProject.sourceCode["package.json"] = await callGeminiAPI(packageJsonPrompt);
                    }
                }
                
                // Generate database configuration file if database is needed
                if (projectDatabase !== "No database needed") {
                    const dbConfigPrompt = `Create a database configuration file for a ${projectLevel} ${projectType} about "${projectTopic}" using ${projectDatabase}. Include connection settings, schema definition, and sample queries.

 ${dateInfo}

Return only the complete configuration code without any additional explanations.`;
                    
                    let dbFileName = `db-config.${getFileExtension(Array.isArray(projectLanguages) ? projectLanguages[0] : projectLanguages)}`;
                    appState.generatedProject.sourceCode[dbFileName] = await callGeminiAPI(dbConfigPrompt);
                }
                
                // Generate README.md file (already generated above)
                appState.generatedProject.sourceCode["README.md"] = appState.generatedProject.readme;
                
            } catch (error) {
                console.error('Error generating source code:', error);
                showNotification(`Error generating source code: ${error.message}`, 'error');
            }
        }

        // Get file extension based on programming language
        function getFileExtension(language) {
            const extensions = {
                "JavaScript/TypeScript": "js",
                "Python": "py",
                "Java": "java",
                "C#": "cs",
                "PHP": "php",
                "Ruby": "rb",
                "Go": "go",
                "Swift": "swift",
                "Kotlin": "kt",
                "C++": "cpp",
                "C": "c",
                "Rust": "rs",
                "SQL": "sql",
                "HTML/CSS": "html"
            };
            
            return extensions[language] || "txt";
        }

        // Prepare project file list for display
        function prepareProjectFileList() {
            const fileList = [];
            
            // Add documentation file
            fileList.push({
                name: "Documentation.html",
                size: "~" + Math.round(appState.generatedProject.documentation.length / 1024) + " KB",
                type: "documentation"
            });
            
            // Add requirements file
            fileList.push({
                name: "Requirements.html",
                size: "~" + Math.round(appState.generatedProject.requirements.length / 1024) + " KB",
                type: "requirements"
            });
            
            // Add workflow file
            fileList.push({
                name: "Workflow.svg",
                size: "~" + Math.round(appState.generatedProject.workflow.length / 1024) + " KB",
                type: "workflow"
            });
            
            // Add source code files
            for (const [fileName, content] of Object.entries(appState.generatedProject.sourceCode)) {
                fileList.push({
                    name: fileName,
                    size: "~" + Math.round(content.length / 1024) + " KB",
                    type: "source"
                });
            }
            
            appState.projectFiles = fileList;
            
            // Render file list in UI
            elements.projectFileList.innerHTML = fileList.map(file => `
                <div class="file-item">
                    <div class="file-name">${file.name}</div>
                    <div class="file-size">${file.size}</div>
                </div>
            `).join('');
        }

        // Download Project as ZIP
        async function downloadProject() {
            try {
                // Create a new JSZip instance
                const zip = new JSZip();
                
                // Create a folder for the project
                const projectFolder = zip.folder(appState.projectTopic.replace(/\s+/g, '_'));
                
                // Add documentation
                projectFolder.file("Documentation.html", appState.generatedProject.documentation);
                
                // Add requirements
                projectFolder.file("Requirements.html", appState.generatedProject.requirements);
                
                // Add workflow
                projectFolder.file("Workflow.svg", appState.generatedProject.workflow);
                
                // Add source code files
                const sourceFolder = projectFolder.folder("Source_Code");
                for (const [fileName, content] of Object.entries(appState.generatedProject.sourceCode)) {
                    sourceFolder.file(fileName, content);
                }
                
                // Generate the ZIP file
                const content = await zip.generateAsync({type: "blob"});
                
                // Save the ZIP file
                saveAs(content, `${appState.projectTopic.replace(/\s+/g, '_')}_Project.zip`);
                
                showNotification('Project downloaded successfully!');
            } catch (error) {
                console.error('Error downloading project:', error);
                showNotification(`Error downloading project: ${error.message}`, 'error');
            }
        }

        // Preview Documentation
        function previewDocumentation() {
            const newWindow = window.open();
            newWindow.document.write(appState.generatedProject.documentation);
            newWindow.document.close();
        }

        // Reset for New Project
        function resetForNewProject() {
            appState.projectTopic = '';
            appState.projectLevel = '';
            appState.projectType = '';
            appState.projectLanguages = [];
            appState.projectFramework = '';
            appState.projectDatabase = '';
            appState.projectUI = '';
            appState.projectDocumentation = '';
            appState.projectDeployment = '';
            appState.projectFont = '';
            appState.selectedProjectFont = '';
            appState.projectQuestions = [];
            appState.projectAnswers = [];
            appState.currentProjectQuestionIndex = 0;
            appState.projectClassificationQuestions = [];
            appState.projectClassificationAnswers = [];
            appState.currentProjectClassificationQuestionIndex = 0;
            appState.generatedProject = {};
            appState.projectFiles = [];
            appState.includeCurrentDate = false;
            appState.currentDateTime = '';
            elements.projectTopicInput.value = '';
            elements.projectLevelSelect.value = '';
            showSection('projectTopic');
        }

        // History Management
        function saveToHistory(topic, content, type) {
            const historyItem = {
                id: Date.now(),
                topic: topic,
                type: type,
                timestamp: new Date().toISOString(),
                content: content
            };
            
            if (type === 'presentation') {
                appState.presentationHistory.unshift(historyItem);
                // Keep only the last 10 presentations
                if (appState.presentationHistory.length > 10) {
                    appState.presentationHistory = appState.presentationHistory.slice(0, 10);
                }
                localStorage.setItem('presentationHistory', JSON.stringify(appState.presentationHistory));
            } else if (type === 'report') {
                appState.reportHistory.unshift(historyItem);
                // Keep only the last 10 reports
                if (appState.reportHistory.length > 10) {
                    appState.reportHistory = appState.reportHistory.slice(0, 10);
                }
                localStorage.setItem('reportHistory', JSON.stringify(appState.reportHistory));
            } else if (type === 'assignment') {
                appState.assignmentHistory.unshift(historyItem);
                // Keep only the last 10 assignments
                if (appState.assignmentHistory.length > 10) {
                    appState.assignmentHistory = appState.assignmentHistory.slice(0, 10);
                }
                localStorage.setItem('assignmentHistory', JSON.stringify(appState.assignmentHistory));
            } else if (type === 'project') {
                appState.projectHistory.unshift(historyItem);
                // Keep only the last 10 projects
                if (appState.projectHistory.length > 10) {
                    appState.projectHistory = appState.projectHistory.slice(0, 10);
                }
                localStorage.setItem('projectHistory', JSON.stringify(appState.projectHistory));
            }
            
            loadHistory();
        }

        function loadHistory() {
            const savedPresentationHistory = localStorage.getItem('presentationHistory');
            const savedReportHistory = localStorage.getItem('reportHistory');
            const savedAssignmentHistory = localStorage.getItem('assignmentHistory');
            const savedProjectHistory = localStorage.getItem('projectHistory');
            
            if (savedPresentationHistory) {
                appState.presentationHistory = JSON.parse(savedPresentationHistory);
            }
            
            if (savedReportHistory) {
                appState.reportHistory = JSON.parse(savedReportHistory);
            }
            
            if (savedAssignmentHistory) {
                appState.assignmentHistory = JSON.parse(savedAssignmentHistory);
            }
            
            if (savedProjectHistory) {
                appState.projectHistory = JSON.parse(savedProjectHistory);
            }
            
            renderHistory();
        }

        function renderHistory() {
            const allHistory = [
                ...appState.presentationHistory.map(item => ({...item, type: 'presentation'})),
                ...appState.reportHistory.map(item => ({...item, type: 'report'})),
                ...appState.assignmentHistory.map(item => ({...item, type: 'assignment'})),
                ...appState.projectHistory.map(item => ({...item, type: 'project'}))
            ].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            if (allHistory.length === 0) {
                elements.historyContainer.innerHTML = '<p>No history yet.</p>';
                return;
            }
            
            elements.historyContainer.innerHTML = allHistory.map(item => `
                <div class="history-item">
                    <div>
                        <h3>${item.topic} <span style="font-size: 0.8rem; opacity: 0.7;">(${item.type})</span></h3>
                        <p>${new Date(item.timestamp).toLocaleString()}</p>
                    </div>
                    <div>
                        <button onclick="loadFromHistory(${item.id}, '${item.type}')">Load</button>
                        <button onclick="deleteHistoryItem(${item.id}, '${item.type}')">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        function loadFromHistory(id, type) {
            let item;
            if (type === 'presentation') {
                item = appState.presentationHistory.find(item => item.id === id);
                if (item) {
                    appState.generatedPresentation = item.content;
                    appState.topic = item.topic;
                    showSection('preview');
                }
            } else if (type === 'report') {
                item = appState.reportHistory.find(item => item.id === id);
                if (item) {
                    appState.generatedReport = item.content;
                    appState.reportTopic = item.topic;
                    showSection('reportPreview');
                }
            } else if (type === 'assignment') {
                item = appState.assignmentHistory.find(item => item.id === id);
                if (item) {
                    appState.generatedAssignment = item.content;
                    appState.assignmentTopic = item.topic;
                    showSection('assignmentPreview');
                }
            } else if (type === 'project') {
                item = appState.projectHistory.find(item => item.id === id);
                if (item) {
                    appState.generatedProject = item.content;
                    appState.projectTopic = item.topic;
                    prepareProjectFileList();
                    showSection('projectPreview');
                }
            }
        }

        function deleteHistoryItem(id, type) {
            if (type === 'presentation') {
                appState.presentationHistory = appState.presentationHistory.filter(item => item.id !== id);
                localStorage.setItem('presentationHistory', JSON.stringify(appState.presentationHistory));
            } else if (type === 'report') {
                appState.reportHistory = appState.reportHistory.filter(item => item.id !== id);
                localStorage.setItem('reportHistory', JSON.stringify(appState.reportHistory));
            } else if (type === 'assignment') {
                appState.assignmentHistory = appState.assignmentHistory.filter(item => item.id !== id);
                localStorage.setItem('assignmentHistory', JSON.stringify(appState.assignmentHistory));
            } else if (type === 'project') {
                appState.projectHistory = appState.projectHistory.filter(item => item.id !== id);
                localStorage.setItem('projectHistory', JSON.stringify(appState.projectHistory));
            }
            loadHistory();
            showNotification('Item removed from history');
        }

        function clearHistory() {
            if (confirm('Are you sure you want to clear all history?')) {
                appState.presentationHistory = [];
                appState.reportHistory = [];
                appState.assignmentHistory = [];
                appState.projectHistory = [];
                localStorage.removeItem('presentationHistory');
                localStorage.removeItem('reportHistory');
                localStorage.removeItem('assignmentHistory');
                localStorage.removeItem('projectHistory');
                renderHistory();
                showNotification('History cleared');
            }
        }

        // Utility Functions
        function showNotification(message, type = 'success') {
            elements.notification.textContent = message;
            elements.notification.className = `notification ${type}`;
            elements.notification.classList.add('show');
            
            setTimeout(() => {
                elements.notification.classList.remove('show');
            }, 3000);
        }

        // Expose functions to global scope for onclick handlers
        window.loadFromHistory = loadFromHistory;
        window.deleteHistoryItem = deleteHistoryItem;

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>