<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Essential Meta Tags -->
    <title>HOPE-PPT | AI-Powered Presentation Generator</title>
    <meta name="description" content="Create stunning interactive presentations with AI. HOPE-PPT generates custom 3D presentations using Gemini AI with beautiful animations and themes.">
    <meta name="keywords" content="presentation generator, AI presentations, 3D slides, HOPE-PPT, Gemini AI, interactive presentations, slide creator">
    <meta name="author" content="Justin">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://hope-ppt.vercel.app">
    
    <!-- Open Graph (OG) Tags -->
    <meta property="og:title" content="HOPE-PPT | AI-Powered Presentation Generator">
    <meta property="og:description" content="Create stunning interactive presentations with AI. HOPE-PPT generates custom 3D presentations using Gemini AI with beautiful animations and themes.">
    <meta property="og:image" content="https://hope-ppt.vercel.app/images/og-preview.jpg">
    <meta property="og:url" content="https://hope-ppt.vercel.app">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="HOPE-PPT">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="HOPE-PPT | AI-Powered Presentation Generator">
    <meta name="twitter:description" content="Create stunning interactive presentations with AI. HOPE-PPT generates custom 3D presentations using Gemini AI with beautiful animations and themes.">
    <meta name="twitter:image" content="https://hope-ppt.vercel.app/images/twitter-preview.jpg">
    <meta name="twitter:site" content="@hopeppt">
    <meta name="twitter:creator" content="@justindev">
    
    <!-- Additional Meta Tags -->
    <meta name="theme-color" content="#3498db">
    <meta name="msapplication-TileColor" content="#3498db">
    <meta name="application-name" content="HOPE-PPT">
    <meta name="apple-mobile-web-app-title" content="HOPE-PPT">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
    
    <!-- Existing scripts and styles -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
    <style>
        /* All existing styles remain unchanged */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #000000, #1a1a2e);
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        #three-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 80px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #3498db, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section {
            display: none;
            animation: fadeIn 0.5s ease-in-out;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }

        input, textarea {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 16px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(52, 152, 219, 0.3);
            transition: all 0.3s ease;
        }

        input:focus, textarea:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.4);
            border-color: rgba(52, 152, 219, 0.6);
        }

        input::placeholder, textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-top: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
            background: linear-gradient(45deg, #2980b9, #3498db);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .loading-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 60vh;
        }

        .loading-text {
            font-size: 2rem;
            margin-bottom: 20px;
            animation: pulse 1.5s infinite;
            text-align: center;
            color: #3498db;
        }

        .loading-credit {
            font-size: 1.2rem;
            margin-top: 10px;
            opacity: 0;
            animation: fadeIn 1s forwards;
            animation-delay: 0.5s;
            color: rgba(255, 255, 255, 0.8);
        }

        .loading-credit:nth-child(3) {
            animation-delay: 1s;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .question-container {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(52, 152, 219, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #3498db, #2980b9);
            width: 0%;
            transition: width 0.3s ease;
        }

        .history-item {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(52, 152, 219, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .history-item button {
            padding: 8px 12px;
            font-size: 14px;
        }

        .preview-container {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(52, 152, 219, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transform: translateX(120%);
            transition: transform 0.3s ease;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: rgba(231, 76, 60, 0.9);
        }

        .generating-animation {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 60vh;
        }

        .generating-text {
            font-size: 2rem;
            margin-bottom: 20px;
            text-align: center;
            color: #3498db;
        }

        .lottie-container {
            width: 200px;
            height: 200px;
            margin: 20px 0;
        }

        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(15px);
            padding: 15px;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            border-top: 1px solid rgba(52, 152, 219, 0.3);
            z-index: 100;
        }

        .option-container {
            margin-top: 15px;
        }

        .option {
            display: block;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option:hover {
            background: rgba(52, 152, 219, 0.2);
            border-color: rgba(52, 152, 219, 0.6);
        }

        .option.selected {
            background: rgba(52, 152, 219, 0.3);
            border-color: #3498db;
        }

        .option input[type="radio"] {
            display: none;
        }

        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000000, #1a1a2e);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 1s ease;
        }

        .splash-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .splash-title {
            font-size: 3rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #3498db, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .splash-subtitle {
            font-size: 1.5rem;
            margin-bottom: 30px;
            color: rgba(255, 255, 255, 0.8);
        }

        .splash-animation {
            width: 300px;
            height: 300px;
            margin: 20px auto;
        }

        .splash-footer {
            margin-top: 40px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .splash-continue {
            margin-top: 30px;
            padding: 12px 30px;
            font-size: 1.1rem;
            background: linear-gradient(45deg, #3498db, #2980b9);
            border: none;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .splash-continue:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(52, 152, 219, 0.4);
        }

        .history-btn {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
            z-index: 99;
            transition: all 0.3s ease;
        }

        .history-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.6);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            button {
                width: 100%;
                margin-right: 0;
            }
            
            .splash-title {
                font-size: 2.5rem;
            }
            
            .splash-subtitle {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splash-screen" class="splash-screen">
        <div class="splash-content">
            <h1 class="splash-title">HOPE-PPT</h1>
            <p class="splash-subtitle">Create stunning interactive presentations with AI</p>
            <div class="splash-animation">
                <lottie-player src="https://assets4.lottiefiles.com/packages/lf20_DMgKk1.json" background="transparent" speed="1" loop autoplay></lottie-player>
            </div>
            <div class="splash-footer">
                <p>Developed by Justin</p>
                <p>Under HOPE Research & development Team</p>
            </div>
            <button class="splash-continue" id="continue-to-app">Continue to App</button>
        </div>
    </div>

    <div id="three-background"></div>
    
    <div class="container">
        <h1>HOPE-PPT</h1>
        
        <!-- API Key Section -->
        <div id="api-key-section" class="section active">
            <div class="form-group">
                <label for="api-key">Enter your Gemini API Key:</label>
                <input type="password" id="api-key" placeholder="Your Gemini API Key">
            </div>
            <button id="save-api-key">Save API Key</button>
            <div id="api-status"></div>
        </div>
        
        <!-- Loading Screen -->
        <div id="loading-section" class="section">
            <div class="loading-screen">
                <div class="loading-text">AI now Getting ready</div>
                <div class="loading-credit">Developed by Justin</div>
                <div class="loading-credit">Developed under HOPE Research & development Team</div>
                <div class="lottie-container">
                    <lottie-player src="https://assets9.lottiefiles.com/packages/lf20_DMgKk1.json" background="transparent" speed="1" loop autoplay></lottie-player>
                </div>
            </div>
        </div>
        
        <!-- Topic Input Section -->
        <div id="topic-section" class="section">
            <div class="form-group">
                <label for="presentation-topic">Enter your presentation topic:</label>
                <input type="text" id="presentation-topic" placeholder="e.g., Climate Change, Artificial Intelligence, etc.">
            </div>
            <button id="generate-questions">Generate Questions</button>
        </div>
        
        <!-- Questions Section -->
        <div id="questions-section" class="section">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div id="questions-container"></div>
            <button id="generate-presentation" disabled>Generate Presentation</button>
        </div>
        
        <!-- Generating Section -->
        <div id="generating-section" class="section">
            <div class="generating-animation">
                <div class="generating-text">Creating your presentation...</div>
                <div class="lottie-container">
                    <lottie-player src="https://assets4.lottiefiles.com/packages/lf20_fcfjwiyb.json" background="transparent" speed="1" loop autoplay></lottie-player>
                </div>
                <p>This may take a moment as we generate your custom 3D presentation</p>
            </div>
        </div>
        
        <!-- Preview Section -->
        <div id="preview-section" class="section">
            <h2>Your presentation is ready!</h2>
            <div class="preview-container">
                <button id="preview-btn">Preview in New Tab</button>
                <button id="new-presentation-btn">Create New Presentation</button>
            </div>
        </div>
        
        <!-- History Section -->
        <div id="history-section" class="section">
            <h2>Recent Presentations</h2>
            <div id="history-container"></div>
            <button id="clear-history-btn">Clear History</button>
            <button id="new-presentation-from-history-btn">Create New Presentation</button>
        </div>
    </div>
    
    <footer>
        Developed under HOPE Research Team | Developed by Justin
    </footer>
    
    <button class="history-btn" id="history-toggle" title="View History">ðŸ“‹</button>
    
    <div id="notification" class="notification"></div>

    <script>
        // Application State
        const appState = {
            apiKey: '',
            topic: '',
            theme: '',
            slideCount: '',
            structure: '',
            animationStyle: '',
            colorTheme: '',
            generatedPresentation: '',
            currentQuestionIndex: 0,
            presentationHistory: []
        };

        // DOM Elements
        const sections = {
            apiKey: document.getElementById('api-key-section'),
            loading: document.getElementById('loading-section'),
            topic: document.getElementById('topic-section'),
            questions: document.getElementById('questions-section'),
            generating: document.getElementById('generating-section'),
            preview: document.getElementById('preview-section'),
            history: document.getElementById('history-section')
        };

        const elements = {
            apiKeyInput: document.getElementById('api-key'),
            saveApiKeyBtn: document.getElementById('save-api-key'),
            apiStatus: document.getElementById('api-status'),
            presentationTopic: document.getElementById('presentation-topic'),
            generateQuestionsBtn: document.getElementById('generate-questions'),
            questionsContainer: document.getElementById('questions-container'),
            progressFill: document.getElementById('progress-fill'),
            generatePresentationBtn: document.getElementById('generate-presentation'),
            previewBtn: document.getElementById('preview-btn'),
            newPresentationBtn: document.getElementById('new-presentation-btn'),
            historyContainer: document.getElementById('history-container'),
            clearHistoryBtn: document.getElementById('clear-history-btn'),
            newPresentationFromHistoryBtn: document.getElementById('new-presentation-from-history-btn'),
            notification: document.getElementById('notification'),
            historyToggle: document.getElementById('history-toggle'),
            splashScreen: document.getElementById('splash-screen'),
            continueToApp: document.getElementById('continue-to-app')
        };

        // Gemini API Configuration
        const GEMINI_API_ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent';

        // Initialize Three.js Background
        function initThreeBackground() {
            const container = document.getElementById('three-background');
            
            // Scene
            const scene = new THREE.Scene();
            
            // Camera
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // Renderer
            const renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);
            
            // Create floating particles
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCount = 500;
            const posArray = new Float32Array(particlesCount * 3);
            
            for(let i = 0; i < particlesCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 10;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            // Material
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.02,
                color: 0x3498db,
                transparent: true,
                opacity: 0.8
            });
            
            // Mesh
            const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particlesMesh);
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Animation
            function animate() {
                requestAnimationFrame(animate);
                
                particlesMesh.rotation.x += 0.001;
                particlesMesh.rotation.y += 0.002;
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Initialize Application
        function initApp() {
            // Show splash screen first
            elements.continueToApp.addEventListener('click', () => {
                elements.splashScreen.style.opacity = '0';
                setTimeout(() => {
                    elements.splashScreen.style.display = 'none';
                    // Initialize Three.js background after splash screen
                    initThreeBackground();
                    
                    // Check for existing API key
                    const savedApiKey = localStorage.getItem('geminiApiKey');
                    if (savedApiKey) {
                        appState.apiKey = savedApiKey;
                        elements.apiKeyInput.value = savedApiKey;
                        showSection('topic');
                        loadHistory();
                    } else {
                        showSection('apiKey');
                    }
                }, 1000);
            });

            // Event Listeners
            elements.saveApiKeyBtn.addEventListener('click', saveApiKey);
            elements.generateQuestionsBtn.addEventListener('click', generateQuestions);
            elements.generatePresentationBtn.addEventListener('click', generatePresentation);
            elements.previewBtn.addEventListener('click', previewPresentation);
            elements.newPresentationBtn.addEventListener('click', resetForNewPresentation);
            elements.clearHistoryBtn.addEventListener('click', clearHistory);
            elements.newPresentationFromHistoryBtn.addEventListener('click', () => {
                showSection('topic');
            });
            elements.historyToggle.addEventListener('click', () => {
                if (sections.history.classList.contains('active')) {
                    // If currently showing history, go back to previous section
                    if (appState.generatedPresentation) {
                        showSection('preview');
                    } else {
                        showSection('topic');
                    }
                } else {
                    // Show history section
                    loadHistory();
                    showSection('history');
                }
            });
        }

        // Section Navigation
        function showSection(sectionName) {
            Object.values(sections).forEach(section => {
                section.classList.remove('active');
            });
            sections[sectionName].classList.add('active');
        }

        // API Key Management
        function saveApiKey() {
            const apiKey = elements.apiKeyInput.value.trim();
            if (!apiKey) {
                showNotification('Please enter a valid API key', 'error');
                return;
            }

            // Simple validation - check if it looks like a Gemini API key
            if (!apiKey.startsWith('AIza') || apiKey.length < 20) {
                showNotification('Invalid API key format', 'error');
                return;
            }

            appState.apiKey = apiKey;
            localStorage.setItem('geminiApiKey', apiKey);
            elements.apiStatus.textContent = 'API Key saved successfully!';
            elements.apiStatus.style.color = '#3498db';
            
            // Show loading screen then proceed to topic input
            showSection('loading');
            setTimeout(() => {
                showSection('topic');
                loadHistory();
            }, 3000);
        }

        // Gemini API Call Function
        async function callGeminiAPI(prompt) {
            try {
                const response = await fetch(GEMINI_API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-goog-api-key': appState.apiKey
                    },
                    body: JSON.stringify({
                        contents: [
                            {
                                parts: [
                                    {
                                        text: prompt
                                    }
                                ]
                            }
                        ]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || 'API request failed');
                }

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } catch (error) {
                console.error('Gemini API Error:', error);
                throw error;
            }
        }

        // Topic Input and Question Generation
        function generateQuestions() {
            const topic = elements.presentationTopic.value.trim();
            if (!topic) {
                showNotification('Please enter a presentation topic', 'error');
                return;
            }

            appState.topic = topic;
            elements.generateQuestionsBtn.disabled = true;
            elements.generateQuestionsBtn.textContent = 'Preparing questions...';
            
            // Set predefined questions
            appState.questions = [
                {
                    question: "What theme do you prefer?",
                    options: ["Minimal", "Creative", "Professional", "HighTech"],
                    variable: "theme"
                },
                {
                    question: "How many slides do you want?",
                    options: ["1-4", "1-6", "1-8", "1-10"],
                    variable: "slideCount"
                },
                {
                    question: "What structure do you prefer for each slide?",
                    options: ["Heading with paragraph", "Heading with bullet points", "Heading only"],
                    variable: "structure"
                },
                {
                    question: "What animation style do you prefer?",
                    options: ["Simple", "No animation", "Futuristic"],
                    variable: "animationStyle"
                },
                {
                    question: "What color theme do you prefer?",
                    options: ["Black white with accent", "Black white with blue accent", "Custom color"],
                    variable: "colorTheme"
                },
                {
                    question: "Content Depth Preference?",
                    options: ["Simple Words", "Advanced Terms", "Semi-Advanced Terms"],
                    variable: "termsdepth"
                }
                ,
                {
                    question: "which 3D background do you prefer?",
                    options: ["Stars in Universe", "3D nodes", "3D floating particles"," Abstract shapes", "No background"],
                    variable: "bgitem"
                }
            ];
            
            // Initialize answers array for these questions
            appState.answers = new Array(appState.questions.length).fill('');
            appState.currentQuestionIndex = 0;
            
            // Show the questions section
            showSection('questions');
            renderCurrentQuestion();
        }

        // Render Current Question with Options
        function renderCurrentQuestion() {
            const progress = ((appState.currentQuestionIndex + 1) / appState.questions.length) * 100;
            elements.progressFill.style.width = `${progress}%`;
            
            const currentQuestion = appState.questions[appState.currentQuestionIndex];
            const selectedOption = appState.answers[appState.currentQuestionIndex];
            
            elements.questionsContainer.innerHTML = `
                <div class="question-container">
                    <h3>Question ${appState.currentQuestionIndex + 1} of ${appState.questions.length}</h3>
                    <p>${currentQuestion.question}</p>
                    <div class="option-container">
                        ${currentQuestion.options.map((option, index) => `
                            <label class="option ${selectedOption === option ? 'selected' : ''}">
                                <input type="radio" name="question-${appState.currentQuestionIndex}" value="${option}" ${selectedOption === option ? 'checked' : ''}>
                                ${option}
                            </label>
                        `).join('')}
                    </div>
                    <div style="margin-top: 15px;">
                        ${appState.currentQuestionIndex > 0 ? '<button id="prev-question-btn">Previous</button>' : ''}
                        ${appState.currentQuestionIndex < appState.questions.length - 1 ? '<button id="next-question-btn">Next</button>' : '<button id="finish-questions-btn">Finish</button>'}
                    </div>
                </div>
            `;
            
            // Add event listeners for options
            const optionElements = document.querySelectorAll('.option');
            optionElements.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    optionElements.forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    // Update the answer
                    const input = option.querySelector('input');
                    input.checked = true;
                    // Store the answer in appState using the variable name
                    const variableName = appState.questions[appState.currentQuestionIndex].variable;
                    appState[variableName] = input.value;
                    // Also update the answers array for progress tracking
                    appState.answers[appState.currentQuestionIndex] = input.value;
                });
            });
            
            if (appState.currentQuestionIndex > 0) {
                document.getElementById('prev-question-btn').addEventListener('click', previousQuestion);
            }
            
            if (appState.currentQuestionIndex < appState.questions.length - 1) {
                document.getElementById('next-question-btn').addEventListener('click', nextQuestion);
            } else {
                document.getElementById('finish-questions-btn').addEventListener('click', finishQuestions);
            }
        }

        // Question Navigation
        function nextQuestion() {
            appState.currentQuestionIndex++;
            renderCurrentQuestion();
        }

        function previousQuestion() {
            appState.currentQuestionIndex--;
            renderCurrentQuestion();
        }

        function finishQuestions() {
            // Check if all questions have answers
            const allAnswered = appState.answers.every(answer => answer.trim() !== '');
            if (!allAnswered) {
                showNotification('Please answer all questions before proceeding', 'error');
                return;
            }
            
            elements.generatePresentationBtn.disabled = false;
            showNotification('All questions answered. You can now generate your presentation!');
        }

        // Presentation Generation
        async function generatePresentation() {
            elements.generatePresentationBtn.disabled = true;
            elements.generatePresentationBtn.textContent = 'Generating presentation...';
            
            // Show generating animation
            showSection('generating');
            
            try {
                // Extract the parameters from appState
                const { topic, theme, slideCount, structure, animationStyle, colorTheme,bgitem,termsdepth } = appState;
                
                // Build the prompt
                const prompt = `Create a complete HTML, CSS, and JavaScript file for a presentation about "${topic}". The presentation should have the following features:

1. Fullscreen functionality: When the user presses the 'F' key, the presentation should enter fullscreen mode.
2. Navigation: Include arrow key navigation (left and right arrows) to move between slides in both directions.
3. Design: Use clean, professional designs with glassmorphism UI elements. The UI should have a glass-like appearance with backdrop blur effects.
4. Color scheme: Use colors suitable for the topic "${topic}". Apply the selected color theme: "${colorTheme}".
5. 3D theme background: Slide should have a Three.js 3D particle background as "${bgitem}".
6. Content depth: Use "${termsdepth}" for the content language style.
7. Animations: Use CSS for all animations. The animation style should be "${animationStyle}".
8. Structure: Each slide should follow the "${structure}" format.
9. Theme: The overall theme should be "${theme}".
10. Slide count: Create ${slideCount} slides with well-organized content.

Additional requirements:
- Include slide indicators (dots) at the bottom to show current slide position.
- Add Previous/Next buttons for navigation.
- Make the presentation responsive for different screen sizes.
- Include a watermark "Developed under HOPE Research Team" and "By Justin" in the bottom-right corner of each slide.
- Use semantic HTML5 tags throughout.
- Add smooth transitions between slides.
- Include professional typography with clear hierarchy.

The presentation should be structured as follows:
1. Title slide with the topic "${topic}" and a subtitle.
2. Introduction slide explaining key concepts.
3. Main content slides with detailed information.
4. Conclusion slide with key takeaways.

3D theme background: Slide should have a Three.js 3D particle background as "${bgitem}".
Return only the complete HTML code without any additional explanations.`;
                
                const presentationHTML = await callGeminiAPI(prompt);
                
                // Ensure watermark is present
                const finalHTML = ensureWatermark(presentationHTML);
                
                appState.generatedPresentation = finalHTML;
                
                // Save to history
                saveToHistory(appState.topic, finalHTML);
                
                // Show preview section
                showSection('preview');
            } catch (error) {
                showNotification(`Error generating presentation: ${error.message}`, 'error');
                elements.generatePresentationBtn.disabled = false;
                elements.generatePresentationBtn.textContent = 'Generate Presentation';
                showSection('questions');
            }
        }

        // Ensure watermark is present in the presentation
        function ensureWatermark(html) {
            // Check if watermark is already present
            if (html.includes('Developed under HOPE Research Team') && html.includes('By Justin')) {
                return html;
            }
            
            // Find each slide and add watermark if not present
            const slidePattern = /<div class="slide-content">(.*?)<\/div>/gs;
            const watermark = '<div class="watermark">Developed under HOPE Research Team<br> by Justin</div>';
            
            return html.replace(slidePattern, (match, content) => {
                if (!content.includes('watermark')) {
                    return `<div class="slide-content">${content}${watermark}</div>`;
                }
                return match;
            });
        }

        // Preview Function
        function previewPresentation() {
            const newWindow = window.open();
            newWindow.document.write(appState.generatedPresentation);
            newWindow.document.close();
        }

        // History Management
        function saveToHistory(topic, presentation) {
            const historyItem = {
                id: Date.now(),
                topic: topic,
                timestamp: new Date().toISOString(),
                presentation: presentation
            };
            
            appState.presentationHistory.unshift(historyItem);
            
            // Keep only the last 10 presentations
            if (appState.presentationHistory.length > 10) {
                appState.presentationHistory = appState.presentationHistory.slice(0, 10);
            }
            
            localStorage.setItem('presentationHistory', JSON.stringify(appState.presentationHistory));
            loadHistory();
        }

        function loadHistory() {
            const savedHistory = localStorage.getItem('presentationHistory');
            if (savedHistory) {
                appState.presentationHistory = JSON.parse(savedHistory);
                renderHistory();
            }
        }

        function renderHistory() {
            if (appState.presentationHistory.length === 0) {
                elements.historyContainer.innerHTML = '<p>No presentation history yet.</p>';
                return;
            }
            
            elements.historyContainer.innerHTML = appState.presentationHistory.map(item => `
                <div class="history-item">
                    <div>
                        <h3>${item.topic}</h3>
                        <p>${new Date(item.timestamp).toLocaleString()}</p>
                    </div>
                    <div>
                        <button onclick="loadPresentationFromHistory(${item.id})">Load</button>
                        <button onclick="deleteHistoryItem(${item.id})">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        function loadPresentationFromHistory(id) {
            const item = appState.presentationHistory.find(item => item.id === id);
            if (item) {
                appState.generatedPresentation = item.presentation;
                appState.topic = item.topic;
                showSection('preview');
            }
        }

        function deleteHistoryItem(id) {
            appState.presentationHistory = appState.presentationHistory.filter(item => item.id !== id);
            localStorage.setItem('presentationHistory', JSON.stringify(appState.presentationHistory));
            loadHistory();
            showNotification('Presentation removed from history');
        }

        function clearHistory() {
            if (confirm('Are you sure you want to clear all presentation history?')) {
                appState.presentationHistory = [];
                localStorage.removeItem('presentationHistory');
                renderHistory();
                showNotification('Presentation history cleared');
            }
        }

        // Reset for New Presentation
        function resetForNewPresentation() {
            appState.topic = '';
            appState.theme = '';
            appState.slideCount = '';
            appState.structure = '';
            appState.animationStyle = '';
            appState.colorTheme = '';
            appState.questions = [];
            appState.answers = [];
            appState.currentQuestionIndex = 0;
            elements.presentationTopic.value = '';
            showSection('topic');
        }

        // Utility Functions
        function showNotification(message, type = 'success') {
            elements.notification.textContent = message;
            elements.notification.className = `notification ${type}`;
            elements.notification.classList.add('show');
            
            setTimeout(() => {
                elements.notification.classList.remove('show');
            }, 3000);
        }

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>